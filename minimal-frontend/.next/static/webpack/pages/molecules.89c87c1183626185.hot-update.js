"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/molecules",{

/***/ "./utils/api.js":
/*!**********************!*\
  !*** ./utils/api.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMolecule: function() { return /* binding */ addMolecule; },\n/* harmony export */   checkConvexConnection: function() { return /* binding */ checkConvexConnection; },\n/* harmony export */   deleteMolecule: function() { return /* binding */ deleteMolecule; },\n/* harmony export */   getMixture: function() { return /* binding */ getMixture; },\n/* harmony export */   getMixtures: function() { return /* binding */ getMixtures; },\n/* harmony export */   getMolecule: function() { return /* binding */ getMolecule; },\n/* harmony export */   getMoleculeDepiction: function() { return /* binding */ getMoleculeDepiction; },\n/* harmony export */   getMolecules: function() { return /* binding */ getMolecules; },\n/* harmony export */   getRDKitProperties: function() { return /* binding */ getRDKitProperties; }\n/* harmony export */ });\n/**\n * API utility functions for fetching data from the CryoProtect backend\n * Supports both REST API and Convex\n * Enhanced with circuit breaker pattern, retry mechanisms, and fallbacks\n */ // Convex client import disabled for minimal deployment\n// import { convex } from '../src/convex/client';\n// Base API URLs\nconst API_ENDPOINTS = {\n    HEROKU_API: \"https://cryoprotect-8030e4025428.herokuapp.com/api\",\n    RDKIT_API: \"https://cryoprotect-rdkit.fly.dev\",\n    CONVEX: \"https://primary-meerkat-478.convex.cloud\"\n};\n// Disable Convex for minimal deployment\nconst USE_CONVEX = false;\n// Fallback mock data in case the API is not available\nconst MOCK_DATA = {\n    molecules: [\n        {\n            id: 1,\n            name: \"Glycerol\",\n            formula: \"C3H8O3\",\n            pubchem_cid: \"753\",\n            smiles: \"C(C(CO)O)O\",\n            molecular_weight: 92.09,\n            is_cryoprotectant: true,\n            description: \"A common cryoprotectant used in various applications.\"\n        },\n        {\n            id: 2,\n            name: \"Dimethyl Sulfoxide (DMSO)\",\n            formula: \"C2H6OS\",\n            pubchem_cid: \"679\",\n            smiles: \"CS(=O)C\",\n            molecular_weight: 78.13,\n            is_cryoprotectant: true,\n            description: \"A widely used penetrating cryoprotectant.\"\n        },\n        {\n            id: 3,\n            name: \"Ethylene Glycol\",\n            formula: \"C2H6O2\",\n            pubchem_cid: \"174\",\n            smiles: \"OCCO\",\n            molecular_weight: 62.07,\n            is_cryoprotectant: true,\n            description: \"Used in cryopreservation of embryos and tissues.\"\n        },\n        {\n            id: 4,\n            name: \"Propylene Glycol\",\n            formula: \"C3H8O2\",\n            pubchem_cid: \"1030\",\n            smiles: \"CC(O)CO\",\n            molecular_weight: 76.09,\n            is_cryoprotectant: true,\n            description: \"Used as a cryoprotectant for various biological materials.\"\n        }\n    ],\n    mixtures: [\n        {\n            id: 1,\n            name: \"VS55\",\n            description: \"A cryoprotectant mixture used for organ preservation.\",\n            components: [\n                {\n                    molecule: {\n                        id: 1,\n                        name: \"Glycerol\",\n                        formula: \"C3H8O3\"\n                    },\n                    concentration: 15,\n                    concentration_unit: \"%\",\n                    role: \"Primary cryoprotectant\"\n                },\n                {\n                    molecule: {\n                        id: 2,\n                        name: \"Dimethyl Sulfoxide (DMSO)\",\n                        formula: \"C2H6OS\"\n                    },\n                    concentration: 20,\n                    concentration_unit: \"%\",\n                    role: \"Penetrating cryoprotectant\"\n                },\n                {\n                    molecule: {\n                        id: 3,\n                        name: \"Ethylene Glycol\",\n                        formula: \"C2H6O2\"\n                    },\n                    concentration: 20,\n                    concentration_unit: \"%\",\n                    role: \"Penetrating cryoprotectant\"\n                }\n            ]\n        },\n        {\n            id: 2,\n            name: \"Standard Cell Freezing Medium\",\n            description: \"Common mixture for cell line preservation.\",\n            components: [\n                {\n                    molecule: {\n                        id: 2,\n                        name: \"Dimethyl Sulfoxide (DMSO)\",\n                        formula: \"C2H6OS\"\n                    },\n                    concentration: 10,\n                    concentration_unit: \"%\",\n                    role: \"Primary cryoprotectant\"\n                }\n            ]\n        }\n    ],\n    // Mock SVG data for molecule depictions (minimal example)\n    molecular_depictions: {\n        \"C(C(CO)O)O\": '<svg version=\"1.1\" id=\"mol-glycerol\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"300px\" height=\"200px\" viewBox=\"0 0 300 200\" enable-background=\"new 0 0 300 200\">\\n      <rect fill=\"#FFFFFF\" width=\"300\" height=\"200\"/>\\n      <g transform=\"translate(10,10) scale(2.8)\">\\n        <path fill=\"none\" stroke=\"#000000\" stroke-width=\"1.5\" d=\"M 50,34.6 L 60,40 L 70,34.6\"/>\\n        <path fill=\"none\" stroke=\"#000000\" stroke-width=\"1.5\" d=\"M 60,40 L 60,50\"/>\\n        <path fill=\"none\" stroke=\"#000000\" stroke-width=\"1.5\" d=\"M 60,50 L 70,55.4\"/>\\n        <path fill=\"none\" stroke=\"#000000\" stroke-width=\"1.5\" d=\"M 60,50 L 50,55.4\"/>\\n        <text x=\"49\" y=\"32\" font-family=\"sans-serif\" font-size=\"10\" fill=\"#FF0000\">OH</text>\\n        <text x=\"69\" y=\"32\" font-family=\"sans-serif\" font-size=\"10\" fill=\"#FF0000\">OH</text>\\n        <text x=\"69\" y=\"62\" font-family=\"sans-serif\" font-size=\"10\" fill=\"#FF0000\">OH</text>\\n      </g>\\n    </svg>',\n        \"CS(=O)C\": '<svg version=\"1.1\" id=\"mol-dmso\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"300px\" height=\"200px\" viewBox=\"0 0 300 200\" enable-background=\"new 0 0 300 200\">\\n      <rect fill=\"#FFFFFF\" width=\"300\" height=\"200\"/>\\n      <g transform=\"translate(10,10) scale(2.8)\">\\n        <path fill=\"none\" stroke=\"#000000\" stroke-width=\"1.5\" d=\"M 50,50 L 60,50\"/>\\n        <path fill=\"none\" stroke=\"#000000\" stroke-width=\"1.5\" d=\"M 60,50 L 70,50\"/>\\n        <path fill=\"none\" stroke=\"#000000\" stroke-width=\"1.5\" d=\"M 60,50 L 60,40\"/>\\n        <text x=\"56\" y=\"54\" font-family=\"sans-serif\" font-size=\"10\" fill=\"#AA5500\">S</text>\\n        <text x=\"59\" y=\"36\" font-family=\"sans-serif\" font-size=\"10\" fill=\"#FF0000\">O</text>\\n      </g>\\n    </svg>'\n    },\n    // Precomputed molecular properties for fallback\n    molecular_properties: {\n        \"C(C(CO)O)O\": {\n            molecular_weight: 92.09,\n            logp: -1.76,\n            num_atoms: 14,\n            num_rings: 0,\n            formula: \"C3H8O3\"\n        },\n        \"CS(=O)C\": {\n            molecular_weight: 78.13,\n            logp: -0.62,\n            num_atoms: 10,\n            num_rings: 0,\n            formula: \"C2H6OS\"\n        },\n        \"OCCO\": {\n            molecular_weight: 62.07,\n            logp: -1.2,\n            num_atoms: 10,\n            num_rings: 0,\n            formula: \"C2H6O2\"\n        },\n        \"CC(O)CO\": {\n            molecular_weight: 76.09,\n            logp: -0.92,\n            num_atoms: 13,\n            num_rings: 0,\n            formula: \"C3H8O2\"\n        }\n    }\n};\n// Utility to check if we're running in the browser\nconst isBrowser = \"object\" !== \"undefined\";\n// Circuit breaker state - persistent across requests in the same session\nconst circuitBreaker = {\n    HEROKU_API: {\n        failureCount: 0,\n        lastFailureTime: null,\n        state: \"CLOSED\",\n        lastSuccessTime: Date.now()\n    },\n    RDKIT_API: {\n        failureCount: 0,\n        lastFailureTime: null,\n        state: \"CLOSED\",\n        lastSuccessTime: Date.now()\n    }\n};\n// Circuit breaker settings\nconst CIRCUIT_BREAKER_THRESHOLD = 5; // Number of failures before opening circuit\nconst CIRCUIT_BREAKER_TIMEOUT = 30000; // Time to wait before trying again (half-open)\nconst MAX_RETRIES = 3; // Maximum number of retries for a request\nconst RETRY_BACKOFF_MS = 1000; // Base backoff time in milliseconds\nconst REQUEST_TIMEOUT_MS = 10000; // Default request timeout (10 seconds)\n/**\n * Check if circuit breaker is open for the given service\n * @param {string} service - Service to check (HEROKU_API, RDKIT_API)\n * @returns {boolean} - True if circuit is open\n */ function isCircuitOpen(service) {\n    const breaker = circuitBreaker[service];\n    if (!breaker) return false;\n    if (breaker.state === \"OPEN\") {\n        // Check if enough time has passed to try again\n        const now = Date.now();\n        if (now - breaker.lastFailureTime > CIRCUIT_BREAKER_TIMEOUT) {\n            // Move to half-open state\n            breaker.state = \"HALF_OPEN\";\n            console.info(\"Circuit breaker for \".concat(service, \" moving to HALF_OPEN state\"));\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\n/**\n * Record a success for the given service\n * @param {string} service - Service to record success for\n */ function recordSuccess(service) {\n    const breaker = circuitBreaker[service];\n    if (!breaker) return;\n    // Update success metrics\n    breaker.lastSuccessTime = Date.now();\n    if (breaker.state === \"HALF_OPEN\") {\n        // Reset circuit breaker on successful test request\n        breaker.failureCount = 0;\n        breaker.state = \"CLOSED\";\n        console.info(\"Circuit breaker for \".concat(service, \" reset to CLOSED state\"));\n    } else if (breaker.state === \"CLOSED\") {\n        // In closed state, reset failure count after a successful request\n        // This helps recover from intermittent failures\n        breaker.failureCount = 0;\n    }\n}\n/**\n * Record a failure for the given service\n * @param {string} service - Service to record failure for\n */ function recordFailure(service) {\n    const breaker = circuitBreaker[service];\n    if (!breaker) return;\n    // Increment failure count and update timestamp\n    breaker.failureCount++;\n    breaker.lastFailureTime = Date.now();\n    if (breaker.state === \"CLOSED\" && breaker.failureCount >= CIRCUIT_BREAKER_THRESHOLD) {\n        // Trip the circuit breaker when failure threshold is reached\n        breaker.state = \"OPEN\";\n        console.warn(\"Circuit breaker for \".concat(service, \" tripped to OPEN state after \").concat(CIRCUIT_BREAKER_THRESHOLD, \" failures\"));\n    } else if (breaker.state === \"HALF_OPEN\") {\n        // If test request fails in half-open state, return to open state\n        breaker.state = \"OPEN\";\n        console.warn(\"Circuit breaker for \".concat(service, \" returned to OPEN state after failed test request\"));\n    }\n}\n/**\n * Enhanced fetch wrapper with error handling, retries, circuit breaker, and fallback to mock data\n * \n * Features:\n * - Circuit breaker pattern to prevent cascading failures\n * - Exponential backoff retry mechanism\n * - Request timeout handling\n * - Graceful degradation with mock data fallbacks\n * - Detailed logging for debugging\n * \n * @param {string} endpoint - API endpoint to fetch from (without base URL)\n * @param {Object} options - Fetch options\n * @param {string} mockDataKey - Key to access mock data if API fails\n * @param {number} retryCount - Current retry count (used internally)\n * @returns {Promise<any>} - Parsed response data\n */ async function fetchWithErrorHandling(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, mockDataKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, retryCount = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    const service = \"HEROKU_API\";\n    const fullUrl = \"\".concat(API_ENDPOINTS.HEROKU_API).concat(endpoint);\n    // Create a request ID for logging\n    const requestId = Math.random().toString(36).substring(2, 10);\n    // Check circuit breaker\n    if (isCircuitOpen(service)) {\n        console.warn(\"[\".concat(requestId, \"] Circuit open for \").concat(service, \", falling back to mock data\"));\n        return getMockData(endpoint, mockDataKey);\n    }\n    // Create AbortController for timeout\n    const controller = typeof AbortController !== \"undefined\" ? new AbortController() : null;\n    const timeoutDuration = options.timeout || REQUEST_TIMEOUT_MS;\n    const timeoutId = controller ? setTimeout(()=>controller.abort(), timeoutDuration) : null;\n    try {\n        console.info(\"[\".concat(requestId, \"] Fetching from \").concat(fullUrl, \" (attempt \").concat(retryCount + 1, \"/\").concat(MAX_RETRIES + 1, \")\"));\n        const response = await fetch(fullUrl, {\n            ...options,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/json\",\n                \"X-Request-ID\": requestId,\n                ...options.headers\n            },\n            mode: \"cors\",\n            credentials: \"omit\",\n            signal: options.signal || (controller === null || controller === void 0 ? void 0 : controller.signal)\n        });\n        // Clear timeout if set\n        if (timeoutId) clearTimeout(timeoutId);\n        if (!response.ok) {\n            throw new Error(\"API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const data = await response.json();\n        // Record success for circuit breaker\n        recordSuccess(service);\n        return data;\n    } catch (error) {\n        // Clear timeout if still active\n        if (timeoutId) clearTimeout(timeoutId);\n        // Handle timeout errors specifically\n        const isTimeout = error.name === \"AbortError\";\n        const errorMsg = isTimeout ? \"Request timed out after \".concat(timeoutDuration, \"ms\") : error.message;\n        console.error(\"[\".concat(requestId, \"] API request failed (attempt \").concat(retryCount + 1, \"/\").concat(MAX_RETRIES + 1, \"): \").concat(errorMsg));\n        // Record failure for circuit breaker\n        recordFailure(service);\n        // Check if we should retry\n        if (retryCount < MAX_RETRIES) {\n            const backoffTime = RETRY_BACKOFF_MS * Math.pow(2, retryCount);\n            console.info(\"[\".concat(requestId, \"] Retrying in \").concat(backoffTime, \"ms...\"));\n            return new Promise((resolve)=>{\n                setTimeout(()=>{\n                    resolve(fetchWithErrorHandling(endpoint, options, mockDataKey, retryCount + 1));\n                }, backoffTime);\n            });\n        }\n        // Fall back to mock data after all retries are exhausted\n        console.warn(\"[\".concat(requestId, \"] All retries failed, falling back to mock data\"));\n        return getMockData(endpoint, mockDataKey);\n    }\n}\n/**\n * Get mock data for an endpoint\n * @param {string} endpoint - API endpoint\n * @param {string} mockDataKey - Key to access mock data\n * @returns {any} - Mock data\n */ function getMockData(endpoint, mockDataKey) {\n    // If we have mock data for this key, return it\n    if (mockDataKey && MOCK_DATA[mockDataKey]) {\n        console.info(\"Using mock data for \".concat(endpoint, \" with key \").concat(mockDataKey));\n        // Special case for single item requests\n        if (endpoint.includes(\"/\")) {\n            const parts = endpoint.split(\"/\");\n            const id = parts[parts.length - 1];\n            // If the mockDataKey points to an array, find the item with matching ID\n            const items = MOCK_DATA[mockDataKey];\n            if (items && Array.isArray(items)) {\n                const item = items.find((i)=>String(i.id) === String(id));\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return MOCK_DATA[mockDataKey];\n    }\n    // Default mock data for unknown endpoints\n    if (endpoint.includes(\"molecules\")) {\n        return Array.isArray(MOCK_DATA.molecules) ? MOCK_DATA.molecules[0] : null;\n    } else if (endpoint.includes(\"mixtures\")) {\n        return Array.isArray(MOCK_DATA.mixtures) ? MOCK_DATA.mixtures[0] : null;\n    }\n    // No mock data available\n    throw new Error(\"No mock data available for \".concat(endpoint));\n}\n/**\n * Fetch wrapper for RDKit API with circuit breaker\n * @param {string} endpoint - API endpoint to fetch from (e.g., '/calculate', '/depict')\n * @param {Object} data - Request data to send\n * @param {Object} options - Additional fetch options\n * @param {number} retryCount - Current retry count (used internally)\n * @returns {Promise<any>} - Parsed response data\n */ async function fetchRDKitAPI(endpoint, data) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, retryCount = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    const service = \"RDKIT_API\";\n    const fullUrl = \"\".concat(API_ENDPOINTS.RDKIT_API).concat(endpoint);\n    // Create a request ID for logging\n    const requestId = Math.random().toString(36).substring(2, 10);\n    // Check circuit breaker\n    if (isCircuitOpen(service)) {\n        console.warn(\"[\".concat(requestId, \"] Circuit open for \").concat(service));\n        throw new Error(\"RDKit service unavailable (circuit open)\");\n    }\n    // Create AbortController for timeout\n    const controller = typeof AbortController !== \"undefined\" ? new AbortController() : null;\n    const timeoutDuration = options.timeout || REQUEST_TIMEOUT_MS;\n    const timeoutId = controller ? setTimeout(()=>controller.abort(), timeoutDuration) : null;\n    try {\n        console.info(\"[\".concat(requestId, \"] Fetching from \").concat(fullUrl, \" (attempt \").concat(retryCount + 1, \"/\").concat(MAX_RETRIES + 1, \")\"));\n        const response = await fetch(fullUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/json\",\n                \"X-Request-ID\": requestId,\n                ...options.headers\n            },\n            body: JSON.stringify(data),\n            mode: \"cors\",\n            credentials: \"omit\",\n            signal: controller === null || controller === void 0 ? void 0 : controller.signal\n        });\n        // Clear timeout\n        if (timeoutId) clearTimeout(timeoutId);\n        if (!response.ok) {\n            throw new Error(\"RDKit API error: \".concat(response.status, \" \").concat(response.statusText));\n        }\n        const responseData = await response.json();\n        // Record success\n        recordSuccess(service);\n        return responseData;\n    } catch (error) {\n        // Clear timeout if still active\n        if (timeoutId) clearTimeout(timeoutId);\n        // Handle timeout errors specifically\n        const isTimeout = error.name === \"AbortError\";\n        const errorMsg = isTimeout ? \"Request timed out after \".concat(timeoutDuration, \"ms\") : error.message;\n        console.error(\"[\".concat(requestId, \"] RDKit API request failed (attempt \").concat(retryCount + 1, \"/\").concat(MAX_RETRIES + 1, \"): \").concat(errorMsg));\n        // Record failure\n        recordFailure(service);\n        // Check if we should retry\n        if (retryCount < MAX_RETRIES) {\n            const backoffTime = RETRY_BACKOFF_MS * Math.pow(2, retryCount);\n            console.info(\"[\".concat(requestId, \"] Retrying RDKit API in \").concat(backoffTime, \"ms...\"));\n            return new Promise((resolve)=>{\n                setTimeout(()=>{\n                    resolve(fetchRDKitAPI(endpoint, data, options, retryCount + 1));\n                }, backoffTime);\n            });\n        }\n        throw error;\n    }\n}\n/**\n * Get all molecules\n * @returns {Promise<Array>} List of molecules\n */ async function getMolecules() {\n    // Convex functionality disabled for minimal deployment\n    // We'll always use the REST API or mock data\n    // Fall back to REST API\n    return fetchWithErrorHandling(\"/molecules\", {}, \"molecules\");\n}\n/**\n * Get a single molecule by ID\n * @param {string|number} id - Molecule ID\n * @returns {Promise<Object>} Molecule data\n */ async function getMolecule(id) {\n    // Convex functionality disabled for minimal deployment\n    // We'll always use the REST API or mock data\n    // Fall back to REST API\n    return fetchWithErrorHandling(\"/molecules/\".concat(id), {}, \"molecules\");\n}\n/**\n * Get all mixtures \n * @returns {Promise<Array>} List of mixtures\n */ async function getMixtures() {\n    // Convex functionality disabled for minimal deployment\n    // We'll always use the REST API or mock data\n    // Fall back to REST API\n    return fetchWithErrorHandling(\"/mixtures\", {}, \"mixtures\");\n}\n/**\n * Get a single mixture by ID\n * @param {string|number} id - Mixture ID\n * @returns {Promise<Object>} Mixture data\n */ async function getMixture(id) {\n    // Convex functionality disabled for minimal deployment\n    // We'll always use the REST API or mock data\n    // Fall back to REST API\n    return fetchWithErrorHandling(\"/mixtures/\".concat(id), {}, \"mixtures\");\n}\n/**\n * Get RDKit molecular properties with circuit breaker and fallback\n * @param {string} smiles - SMILES notation of the molecule\n * @returns {Promise<Object>} RDKit calculation results\n */ async function getRDKitProperties(smiles) {\n    if (!smiles) {\n        return {\n            error: \"No SMILES provided\",\n            molecular_weight: 0,\n            logp: 0,\n            num_atoms: 0,\n            num_rings: 0\n        };\n    }\n    try {\n        // Request properties from RDKit service\n        const data = await fetchRDKitAPI(\"/calculate\", {\n            smiles\n        });\n        return data;\n    } catch (error) {\n        console.error(\"RDKit properties calculation failed:\", error);\n        // Use fallback property calculation\n        if (MOCK_DATA.molecular_properties[smiles]) {\n            console.info(\"Using pre-computed properties for \".concat(smiles));\n            return {\n                ...MOCK_DATA.molecular_properties[smiles],\n                source: \"fallback\"\n            };\n        }\n        // If no pre-computed data, use rough estimation\n        return {\n            molecular_weight: estimateMolecularWeight(smiles),\n            logp: 0,\n            num_atoms: countAtoms(smiles),\n            num_rings: estimateRingCount(smiles),\n            error: \"Failed to fetch properties from RDKit service, using estimated values\",\n            source: \"estimated\"\n        };\n    }\n}\n/**\n * Generate a 2D depiction of a molecule with circuit breaker and fallback\n * @param {string} smiles - SMILES notation of the molecule\n * @param {Object} options - Optional rendering options (width, height, includeMoleculeDetails)\n * @returns {Promise<string>} SVG depiction\n */ async function getMoleculeDepiction(smiles) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (!smiles) return \"\";\n    const requestData = {\n        smiles,\n        width: options.width || 300,\n        height: options.height || 200,\n        includeMoleculeDetails: options.includeMoleculeDetails || false\n    };\n    try {\n        // Request depiction from RDKit service\n        const data = await fetchRDKitAPI(\"/depict\", requestData);\n        return data.svg || \"\";\n    } catch (error) {\n        console.error(\"RDKit depiction generation failed:\", error);\n        // Try to use cached SVG depiction if available\n        if (MOCK_DATA.molecular_depictions[smiles]) {\n            console.info(\"Using cached depiction for \".concat(smiles));\n            return MOCK_DATA.molecular_depictions[smiles];\n        }\n        // Otherwise return empty string to show fallback UI\n        return \"\";\n    }\n}\n/**\n * Very basic estimation of molecular weight from SMILES (fallback method)\n * This is a very rough approximation and should only be used when RDKit is unavailable\n * @param {string} smiles - SMILES notation\n * @returns {number} Estimated molecular weight\n */ function estimateMolecularWeight(smiles) {\n    // This is an extremely simplified approach\n    // A real implementation would need to parse the SMILES properly\n    // Count some common atoms\n    const carbonCount = (smiles.match(/C/g) || []).length;\n    const hydrogenCount = (smiles.match(/H/g) || []).length;\n    const oxygenCount = (smiles.match(/O/g) || []).length;\n    const nitrogenCount = (smiles.match(/N/g) || []).length;\n    const sulfurCount = (smiles.match(/S/g) || []).length;\n    const phosphorusCount = (smiles.match(/P/g) || []).length;\n    const fluorineCount = (smiles.match(/F/g) || []).length;\n    const chlorineCount = (smiles.match(/Cl/g) || []).length;\n    const bromineCount = (smiles.match(/Br/g) || []).length;\n    const iodineCount = (smiles.match(/I/g) || []).length;\n    // Approximate weights\n    const C_WEIGHT = 12.01;\n    const H_WEIGHT = 1.01;\n    const O_WEIGHT = 16.00;\n    const N_WEIGHT = 14.01;\n    const S_WEIGHT = 32.07;\n    const P_WEIGHT = 30.97;\n    const F_WEIGHT = 19.00;\n    const CL_WEIGHT = 35.45;\n    const BR_WEIGHT = 79.90;\n    const I_WEIGHT = 126.90;\n    // Rough estimate of weight from atom counts\n    const weight = carbonCount * C_WEIGHT + hydrogenCount * H_WEIGHT + oxygenCount * O_WEIGHT + nitrogenCount * N_WEIGHT + sulfurCount * S_WEIGHT + phosphorusCount * P_WEIGHT + fluorineCount * F_WEIGHT + chlorineCount * CL_WEIGHT + bromineCount * BR_WEIGHT + iodineCount * I_WEIGHT;\n    // Add an estimate for implicit hydrogens\n    // This is a very rough heuristic\n    const implicitHydrogens = Math.max(0, carbonCount * 2);\n    return Math.round((weight + implicitHydrogens * H_WEIGHT) * 100) / 100;\n}\n/**\n * Count atoms in SMILES (fallback method)\n * @param {string} smiles - SMILES notation\n * @returns {number} Approximate atom count\n */ function countAtoms(smiles) {\n    // This is a very simplified approach\n    // We'll count the uppercase letters as a rough proxy for atoms\n    // We'll also check for some common two-letter atoms\n    // Basic pattern for any atom symbol (uppercase letter possibly followed by lowercase letter)\n    const atomPattern = /[A-Z][a-z]?/g;\n    const matches = smiles.match(atomPattern) || [];\n    return matches.length;\n}\n/**\n * Estimate the number of rings in a molecule from SMILES\n * This is a very basic heuristic for when RDKit is unavailable\n * @param {string} smiles - SMILES notation\n * @returns {number} Approximate ring count\n */ function estimateRingCount(smiles) {\n    // Look for digit pairs which indicate ring closures in SMILES\n    const ringDigits = smiles.match(/\\d/g) || [];\n    // Each ring should be counted once (two digits per ring)\n    return Math.floor(ringDigits.length / 2);\n}\n/**\n * Check Convex connection status\n * @returns {Promise<boolean>} True if Convex is connected\n */ async function checkConvexConnection() {\n    // Convex functionality disabled for minimal deployment\n    return false;\n}\n/**\n * Add a new molecule using Convex\n * @param {Object} moleculeData - Data for the new molecule\n * @returns {Promise<Object>} Result of the operation\n */ async function addMolecule(moleculeData) {\n    // Convex functionality disabled for minimal deployment\n    throw new Error(\"Adding molecules is not available in this minimal deployment\");\n}\n/**\n * Delete a molecule using Convex\n * @param {string} id - ID of the molecule to delete\n * @returns {Promise<Object>} Result of the operation\n */ async function deleteMolecule(id) {\n    // Convex functionality disabled for minimal deployment\n    throw new Error(\"Deleting molecules is not available in this minimal deployment\");\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    getMolecules,\n    getMolecule,\n    getMixtures,\n    getMixture,\n    getRDKitProperties,\n    getMoleculeDepiction,\n    checkConvexConnection,\n    addMolecule,\n    deleteMolecule\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUF1RDtJQUN2RCxNQUFNLElBQUltRSxNQUFNO0FBQ2xCO0FBRUEsK0RBQWU7SUFDYjhCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FLO0lBQ0FtQztJQUNBQztJQUNBRTtBQUNGLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9hcGkuanM/YzExMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFQSSB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgZmV0Y2hpbmcgZGF0YSBmcm9tIHRoZSBDcnlvUHJvdGVjdCBiYWNrZW5kXG4gKiBTdXBwb3J0cyBib3RoIFJFU1QgQVBJIGFuZCBDb252ZXhcbiAqIEVuaGFuY2VkIHdpdGggY2lyY3VpdCBicmVha2VyIHBhdHRlcm4sIHJldHJ5IG1lY2hhbmlzbXMsIGFuZCBmYWxsYmFja3NcbiAqL1xuXG4vLyBDb252ZXggY2xpZW50IGltcG9ydCBkaXNhYmxlZCBmb3IgbWluaW1hbCBkZXBsb3ltZW50XG4vLyBpbXBvcnQgeyBjb252ZXggfSBmcm9tICcuLi9zcmMvY29udmV4L2NsaWVudCc7XG5cbi8vIEJhc2UgQVBJIFVSTHNcbmNvbnN0IEFQSV9FTkRQT0lOVFMgPSB7XG4gIEhFUk9LVV9BUEk6ICdodHRwczovL2NyeW9wcm90ZWN0LTgwMzBlNDAyNTQyOC5oZXJva3VhcHAuY29tL2FwaScsXG4gIFJES0lUX0FQSTogJ2h0dHBzOi8vY3J5b3Byb3RlY3QtcmRraXQuZmx5LmRldicsXG4gIENPTlZFWDogJ2h0dHBzOi8vcHJpbWFyeS1tZWVya2F0LTQ3OC5jb252ZXguY2xvdWQnXG59O1xuXG4vLyBEaXNhYmxlIENvbnZleCBmb3IgbWluaW1hbCBkZXBsb3ltZW50XG5jb25zdCBVU0VfQ09OVkVYID0gZmFsc2U7XG5cbi8vIEZhbGxiYWNrIG1vY2sgZGF0YSBpbiBjYXNlIHRoZSBBUEkgaXMgbm90IGF2YWlsYWJsZVxuY29uc3QgTU9DS19EQVRBID0ge1xuICBtb2xlY3VsZXM6IFtcbiAgICB7XG4gICAgICBpZDogMSxcbiAgICAgIG5hbWU6ICdHbHljZXJvbCcsXG4gICAgICBmb3JtdWxhOiAnQzNIOE8zJyxcbiAgICAgIHB1YmNoZW1fY2lkOiAnNzUzJyxcbiAgICAgIHNtaWxlczogJ0MoQyhDTylPKU8nLFxuICAgICAgbW9sZWN1bGFyX3dlaWdodDogOTIuMDksXG4gICAgICBpc19jcnlvcHJvdGVjdGFudDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQSBjb21tb24gY3J5b3Byb3RlY3RhbnQgdXNlZCBpbiB2YXJpb3VzIGFwcGxpY2F0aW9ucy4nXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogMixcbiAgICAgIG5hbWU6ICdEaW1ldGh5bCBTdWxmb3hpZGUgKERNU08pJyxcbiAgICAgIGZvcm11bGE6ICdDMkg2T1MnLFxuICAgICAgcHViY2hlbV9jaWQ6ICc2NzknLFxuICAgICAgc21pbGVzOiAnQ1MoPU8pQycsXG4gICAgICBtb2xlY3VsYXJfd2VpZ2h0OiA3OC4xMyxcbiAgICAgIGlzX2NyeW9wcm90ZWN0YW50OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdBIHdpZGVseSB1c2VkIHBlbmV0cmF0aW5nIGNyeW9wcm90ZWN0YW50LidcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAzLFxuICAgICAgbmFtZTogJ0V0aHlsZW5lIEdseWNvbCcsXG4gICAgICBmb3JtdWxhOiAnQzJINk8yJyxcbiAgICAgIHB1YmNoZW1fY2lkOiAnMTc0JyxcbiAgICAgIHNtaWxlczogJ09DQ08nLFxuICAgICAgbW9sZWN1bGFyX3dlaWdodDogNjIuMDcsXG4gICAgICBpc19jcnlvcHJvdGVjdGFudDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVXNlZCBpbiBjcnlvcHJlc2VydmF0aW9uIG9mIGVtYnJ5b3MgYW5kIHRpc3N1ZXMuJ1xuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDQsXG4gICAgICBuYW1lOiAnUHJvcHlsZW5lIEdseWNvbCcsXG4gICAgICBmb3JtdWxhOiAnQzNIOE8yJyxcbiAgICAgIHB1YmNoZW1fY2lkOiAnMTAzMCcsXG4gICAgICBzbWlsZXM6ICdDQyhPKUNPJyxcbiAgICAgIG1vbGVjdWxhcl93ZWlnaHQ6IDc2LjA5LFxuICAgICAgaXNfY3J5b3Byb3RlY3RhbnQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ1VzZWQgYXMgYSBjcnlvcHJvdGVjdGFudCBmb3IgdmFyaW91cyBiaW9sb2dpY2FsIG1hdGVyaWFscy4nXG4gICAgfVxuICBdLFxuICBtaXh0dXJlczogW1xuICAgIHtcbiAgICAgIGlkOiAxLFxuICAgICAgbmFtZTogJ1ZTNTUnLFxuICAgICAgZGVzY3JpcHRpb246ICdBIGNyeW9wcm90ZWN0YW50IG1peHR1cmUgdXNlZCBmb3Igb3JnYW4gcHJlc2VydmF0aW9uLicsXG4gICAgICBjb21wb25lbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtb2xlY3VsZToge1xuICAgICAgICAgICAgaWQ6IDEsXG4gICAgICAgICAgICBuYW1lOiAnR2x5Y2Vyb2wnLFxuICAgICAgICAgICAgZm9ybXVsYTogJ0MzSDhPMydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmNlbnRyYXRpb246IDE1LFxuICAgICAgICAgIGNvbmNlbnRyYXRpb25fdW5pdDogJyUnLFxuICAgICAgICAgIHJvbGU6ICdQcmltYXJ5IGNyeW9wcm90ZWN0YW50J1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbW9sZWN1bGU6IHtcbiAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgbmFtZTogJ0RpbWV0aHlsIFN1bGZveGlkZSAoRE1TTyknLFxuICAgICAgICAgICAgZm9ybXVsYTogJ0MySDZPUydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmNlbnRyYXRpb246IDIwLFxuICAgICAgICAgIGNvbmNlbnRyYXRpb25fdW5pdDogJyUnLFxuICAgICAgICAgIHJvbGU6ICdQZW5ldHJhdGluZyBjcnlvcHJvdGVjdGFudCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1vbGVjdWxlOiB7XG4gICAgICAgICAgICBpZDogMyxcbiAgICAgICAgICAgIG5hbWU6ICdFdGh5bGVuZSBHbHljb2wnLFxuICAgICAgICAgICAgZm9ybXVsYTogJ0MySDZPMidcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmNlbnRyYXRpb246IDIwLFxuICAgICAgICAgIGNvbmNlbnRyYXRpb25fdW5pdDogJyUnLFxuICAgICAgICAgIHJvbGU6ICdQZW5ldHJhdGluZyBjcnlvcHJvdGVjdGFudCdcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgaWQ6IDIsXG4gICAgICBuYW1lOiAnU3RhbmRhcmQgQ2VsbCBGcmVlemluZyBNZWRpdW0nLFxuICAgICAgZGVzY3JpcHRpb246ICdDb21tb24gbWl4dHVyZSBmb3IgY2VsbCBsaW5lIHByZXNlcnZhdGlvbi4nLFxuICAgICAgY29tcG9uZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbW9sZWN1bGU6IHtcbiAgICAgICAgICAgIGlkOiAyLFxuICAgICAgICAgICAgbmFtZTogJ0RpbWV0aHlsIFN1bGZveGlkZSAoRE1TTyknLFxuICAgICAgICAgICAgZm9ybXVsYTogJ0MySDZPUydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmNlbnRyYXRpb246IDEwLFxuICAgICAgICAgIGNvbmNlbnRyYXRpb25fdW5pdDogJyUnLFxuICAgICAgICAgIHJvbGU6ICdQcmltYXJ5IGNyeW9wcm90ZWN0YW50J1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICBdLFxuICAvLyBNb2NrIFNWRyBkYXRhIGZvciBtb2xlY3VsZSBkZXBpY3Rpb25zIChtaW5pbWFsIGV4YW1wbGUpXG4gIG1vbGVjdWxhcl9kZXBpY3Rpb25zOiB7XG4gICAgJ0MoQyhDTylPKU8nOiBgPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgaWQ9XCJtb2wtZ2x5Y2Vyb2xcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjMwMHB4XCIgaGVpZ2h0PVwiMjAwcHhcIiB2aWV3Qm94PVwiMCAwIDMwMCAyMDBcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgMzAwIDIwMFwiPlxuICAgICAgPHJlY3QgZmlsbD1cIiNGRkZGRkZcIiB3aWR0aD1cIjMwMFwiIGhlaWdodD1cIjIwMFwiLz5cbiAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMCwxMCkgc2NhbGUoMi44KVwiPlxuICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBkPVwiTSA1MCwzNC42IEwgNjAsNDAgTCA3MCwzNC42XCIvPlxuICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBkPVwiTSA2MCw0MCBMIDYwLDUwXCIvPlxuICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBkPVwiTSA2MCw1MCBMIDcwLDU1LjRcIi8+XG4gICAgICAgIDxwYXRoIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiIzAwMDAwMFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIGQ9XCJNIDYwLDUwIEwgNTAsNTUuNFwiLz5cbiAgICAgICAgPHRleHQgeD1cIjQ5XCIgeT1cIjMyXCIgZm9udC1mYW1pbHk9XCJzYW5zLXNlcmlmXCIgZm9udC1zaXplPVwiMTBcIiBmaWxsPVwiI0ZGMDAwMFwiPk9IPC90ZXh0PlxuICAgICAgICA8dGV4dCB4PVwiNjlcIiB5PVwiMzJcIiBmb250LWZhbWlseT1cInNhbnMtc2VyaWZcIiBmb250LXNpemU9XCIxMFwiIGZpbGw9XCIjRkYwMDAwXCI+T0g8L3RleHQ+XG4gICAgICAgIDx0ZXh0IHg9XCI2OVwiIHk9XCI2MlwiIGZvbnQtZmFtaWx5PVwic2Fucy1zZXJpZlwiIGZvbnQtc2l6ZT1cIjEwXCIgZmlsbD1cIiNGRjAwMDBcIj5PSDwvdGV4dD5cbiAgICAgIDwvZz5cbiAgICA8L3N2Zz5gLFxuICAgICdDUyg9TylDJzogYDxzdmcgdmVyc2lvbj1cIjEuMVwiIGlkPVwibW9sLWRtc29cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgeD1cIjBweFwiIHk9XCIwcHhcIiB3aWR0aD1cIjMwMHB4XCIgaGVpZ2h0PVwiMjAwcHhcIiB2aWV3Qm94PVwiMCAwIDMwMCAyMDBcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgMzAwIDIwMFwiPlxuICAgICAgPHJlY3QgZmlsbD1cIiNGRkZGRkZcIiB3aWR0aD1cIjMwMFwiIGhlaWdodD1cIjIwMFwiLz5cbiAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMCwxMCkgc2NhbGUoMi44KVwiPlxuICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBkPVwiTSA1MCw1MCBMIDYwLDUwXCIvPlxuICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBkPVwiTSA2MCw1MCBMIDcwLDUwXCIvPlxuICAgICAgICA8cGF0aCBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMwMDAwMDBcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBkPVwiTSA2MCw1MCBMIDYwLDQwXCIvPlxuICAgICAgICA8dGV4dCB4PVwiNTZcIiB5PVwiNTRcIiBmb250LWZhbWlseT1cInNhbnMtc2VyaWZcIiBmb250LXNpemU9XCIxMFwiIGZpbGw9XCIjQUE1NTAwXCI+UzwvdGV4dD5cbiAgICAgICAgPHRleHQgeD1cIjU5XCIgeT1cIjM2XCIgZm9udC1mYW1pbHk9XCJzYW5zLXNlcmlmXCIgZm9udC1zaXplPVwiMTBcIiBmaWxsPVwiI0ZGMDAwMFwiPk88L3RleHQ+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+YFxuICB9LFxuICAvLyBQcmVjb21wdXRlZCBtb2xlY3VsYXIgcHJvcGVydGllcyBmb3IgZmFsbGJhY2tcbiAgbW9sZWN1bGFyX3Byb3BlcnRpZXM6IHtcbiAgICAnQyhDKENPKU8pTyc6IHtcbiAgICAgIG1vbGVjdWxhcl93ZWlnaHQ6IDkyLjA5LFxuICAgICAgbG9ncDogLTEuNzYsXG4gICAgICBudW1fYXRvbXM6IDE0LFxuICAgICAgbnVtX3JpbmdzOiAwLFxuICAgICAgZm9ybXVsYTogJ0MzSDhPMydcbiAgICB9LFxuICAgICdDUyg9TylDJzoge1xuICAgICAgbW9sZWN1bGFyX3dlaWdodDogNzguMTMsXG4gICAgICBsb2dwOiAtMC42MixcbiAgICAgIG51bV9hdG9tczogMTAsXG4gICAgICBudW1fcmluZ3M6IDAsXG4gICAgICBmb3JtdWxhOiAnQzJINk9TJ1xuICAgIH0sXG4gICAgJ09DQ08nOiB7XG4gICAgICBtb2xlY3VsYXJfd2VpZ2h0OiA2Mi4wNyxcbiAgICAgIGxvZ3A6IC0xLjIsXG4gICAgICBudW1fYXRvbXM6IDEwLFxuICAgICAgbnVtX3JpbmdzOiAwLFxuICAgICAgZm9ybXVsYTogJ0MySDZPMidcbiAgICB9LFxuICAgICdDQyhPKUNPJzoge1xuICAgICAgbW9sZWN1bGFyX3dlaWdodDogNzYuMDksXG4gICAgICBsb2dwOiAtMC45MixcbiAgICAgIG51bV9hdG9tczogMTMsXG4gICAgICBudW1fcmluZ3M6IDAsXG4gICAgICBmb3JtdWxhOiAnQzNIOE8yJ1xuICAgIH1cbiAgfVxufTtcblxuLy8gVXRpbGl0eSB0byBjaGVjayBpZiB3ZSdyZSBydW5uaW5nIGluIHRoZSBicm93c2VyXG5jb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLy8gQ2lyY3VpdCBicmVha2VyIHN0YXRlIC0gcGVyc2lzdGVudCBhY3Jvc3MgcmVxdWVzdHMgaW4gdGhlIHNhbWUgc2Vzc2lvblxuY29uc3QgY2lyY3VpdEJyZWFrZXIgPSB7XG4gIEhFUk9LVV9BUEk6IHtcbiAgICBmYWlsdXJlQ291bnQ6IDAsXG4gICAgbGFzdEZhaWx1cmVUaW1lOiBudWxsLFxuICAgIHN0YXRlOiAnQ0xPU0VEJywgLy8gQ0xPU0VELCBPUEVOLCBIQUxGX09QRU5cbiAgICBsYXN0U3VjY2Vzc1RpbWU6IERhdGUubm93KClcbiAgfSxcbiAgUkRLSVRfQVBJOiB7XG4gICAgZmFpbHVyZUNvdW50OiAwLFxuICAgIGxhc3RGYWlsdXJlVGltZTogbnVsbCxcbiAgICBzdGF0ZTogJ0NMT1NFRCcsIC8vIENMT1NFRCwgT1BFTiwgSEFMRl9PUEVOXG4gICAgbGFzdFN1Y2Nlc3NUaW1lOiBEYXRlLm5vdygpXG4gIH1cbn07XG5cbi8vIENpcmN1aXQgYnJlYWtlciBzZXR0aW5nc1xuY29uc3QgQ0lSQ1VJVF9CUkVBS0VSX1RIUkVTSE9MRCA9IDU7IC8vIE51bWJlciBvZiBmYWlsdXJlcyBiZWZvcmUgb3BlbmluZyBjaXJjdWl0XG5jb25zdCBDSVJDVUlUX0JSRUFLRVJfVElNRU9VVCA9IDMwMDAwOyAvLyBUaW1lIHRvIHdhaXQgYmVmb3JlIHRyeWluZyBhZ2FpbiAoaGFsZi1vcGVuKVxuY29uc3QgTUFYX1JFVFJJRVMgPSAzOyAvLyBNYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIGZvciBhIHJlcXVlc3RcbmNvbnN0IFJFVFJZX0JBQ0tPRkZfTVMgPSAxMDAwOyAvLyBCYXNlIGJhY2tvZmYgdGltZSBpbiBtaWxsaXNlY29uZHNcbmNvbnN0IFJFUVVFU1RfVElNRU9VVF9NUyA9IDEwMDAwOyAvLyBEZWZhdWx0IHJlcXVlc3QgdGltZW91dCAoMTAgc2Vjb25kcylcblxuLyoqXG4gKiBDaGVjayBpZiBjaXJjdWl0IGJyZWFrZXIgaXMgb3BlbiBmb3IgdGhlIGdpdmVuIHNlcnZpY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2aWNlIC0gU2VydmljZSB0byBjaGVjayAoSEVST0tVX0FQSSwgUkRLSVRfQVBJKVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBjaXJjdWl0IGlzIG9wZW5cbiAqL1xuZnVuY3Rpb24gaXNDaXJjdWl0T3BlbihzZXJ2aWNlKSB7XG4gIGNvbnN0IGJyZWFrZXIgPSBjaXJjdWl0QnJlYWtlcltzZXJ2aWNlXTtcbiAgXG4gIGlmICghYnJlYWtlcikgcmV0dXJuIGZhbHNlO1xuICBcbiAgaWYgKGJyZWFrZXIuc3RhdGUgPT09ICdPUEVOJykge1xuICAgIC8vIENoZWNrIGlmIGVub3VnaCB0aW1lIGhhcyBwYXNzZWQgdG8gdHJ5IGFnYWluXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gYnJlYWtlci5sYXN0RmFpbHVyZVRpbWUgPiBDSVJDVUlUX0JSRUFLRVJfVElNRU9VVCkge1xuICAgICAgLy8gTW92ZSB0byBoYWxmLW9wZW4gc3RhdGVcbiAgICAgIGJyZWFrZXIuc3RhdGUgPSAnSEFMRl9PUEVOJztcbiAgICAgIGNvbnNvbGUuaW5mbyhgQ2lyY3VpdCBicmVha2VyIGZvciAke3NlcnZpY2V9IG1vdmluZyB0byBIQUxGX09QRU4gc3RhdGVgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZWNvcmQgYSBzdWNjZXNzIGZvciB0aGUgZ2l2ZW4gc2VydmljZVxuICogQHBhcmFtIHtzdHJpbmd9IHNlcnZpY2UgLSBTZXJ2aWNlIHRvIHJlY29yZCBzdWNjZXNzIGZvclxuICovXG5mdW5jdGlvbiByZWNvcmRTdWNjZXNzKHNlcnZpY2UpIHtcbiAgY29uc3QgYnJlYWtlciA9IGNpcmN1aXRCcmVha2VyW3NlcnZpY2VdO1xuICBpZiAoIWJyZWFrZXIpIHJldHVybjtcbiAgXG4gIC8vIFVwZGF0ZSBzdWNjZXNzIG1ldHJpY3NcbiAgYnJlYWtlci5sYXN0U3VjY2Vzc1RpbWUgPSBEYXRlLm5vdygpO1xuICBcbiAgaWYgKGJyZWFrZXIuc3RhdGUgPT09ICdIQUxGX09QRU4nKSB7XG4gICAgLy8gUmVzZXQgY2lyY3VpdCBicmVha2VyIG9uIHN1Y2Nlc3NmdWwgdGVzdCByZXF1ZXN0XG4gICAgYnJlYWtlci5mYWlsdXJlQ291bnQgPSAwO1xuICAgIGJyZWFrZXIuc3RhdGUgPSAnQ0xPU0VEJztcbiAgICBjb25zb2xlLmluZm8oYENpcmN1aXQgYnJlYWtlciBmb3IgJHtzZXJ2aWNlfSByZXNldCB0byBDTE9TRUQgc3RhdGVgKTtcbiAgfSBlbHNlIGlmIChicmVha2VyLnN0YXRlID09PSAnQ0xPU0VEJykge1xuICAgIC8vIEluIGNsb3NlZCBzdGF0ZSwgcmVzZXQgZmFpbHVyZSBjb3VudCBhZnRlciBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgIC8vIFRoaXMgaGVscHMgcmVjb3ZlciBmcm9tIGludGVybWl0dGVudCBmYWlsdXJlc1xuICAgIGJyZWFrZXIuZmFpbHVyZUNvdW50ID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIFJlY29yZCBhIGZhaWx1cmUgZm9yIHRoZSBnaXZlbiBzZXJ2aWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VydmljZSAtIFNlcnZpY2UgdG8gcmVjb3JkIGZhaWx1cmUgZm9yXG4gKi9cbmZ1bmN0aW9uIHJlY29yZEZhaWx1cmUoc2VydmljZSkge1xuICBjb25zdCBicmVha2VyID0gY2lyY3VpdEJyZWFrZXJbc2VydmljZV07XG4gIGlmICghYnJlYWtlcikgcmV0dXJuO1xuICBcbiAgLy8gSW5jcmVtZW50IGZhaWx1cmUgY291bnQgYW5kIHVwZGF0ZSB0aW1lc3RhbXBcbiAgYnJlYWtlci5mYWlsdXJlQ291bnQrKztcbiAgYnJlYWtlci5sYXN0RmFpbHVyZVRpbWUgPSBEYXRlLm5vdygpO1xuICBcbiAgaWYgKGJyZWFrZXIuc3RhdGUgPT09ICdDTE9TRUQnICYmIGJyZWFrZXIuZmFpbHVyZUNvdW50ID49IENJUkNVSVRfQlJFQUtFUl9USFJFU0hPTEQpIHtcbiAgICAvLyBUcmlwIHRoZSBjaXJjdWl0IGJyZWFrZXIgd2hlbiBmYWlsdXJlIHRocmVzaG9sZCBpcyByZWFjaGVkXG4gICAgYnJlYWtlci5zdGF0ZSA9ICdPUEVOJztcbiAgICBjb25zb2xlLndhcm4oYENpcmN1aXQgYnJlYWtlciBmb3IgJHtzZXJ2aWNlfSB0cmlwcGVkIHRvIE9QRU4gc3RhdGUgYWZ0ZXIgJHtDSVJDVUlUX0JSRUFLRVJfVEhSRVNIT0xEfSBmYWlsdXJlc2ApO1xuICB9IGVsc2UgaWYgKGJyZWFrZXIuc3RhdGUgPT09ICdIQUxGX09QRU4nKSB7XG4gICAgLy8gSWYgdGVzdCByZXF1ZXN0IGZhaWxzIGluIGhhbGYtb3BlbiBzdGF0ZSwgcmV0dXJuIHRvIG9wZW4gc3RhdGVcbiAgICBicmVha2VyLnN0YXRlID0gJ09QRU4nO1xuICAgIGNvbnNvbGUud2FybihgQ2lyY3VpdCBicmVha2VyIGZvciAke3NlcnZpY2V9IHJldHVybmVkIHRvIE9QRU4gc3RhdGUgYWZ0ZXIgZmFpbGVkIHRlc3QgcmVxdWVzdGApO1xuICB9XG59XG5cbi8qKlxuICogRW5oYW5jZWQgZmV0Y2ggd3JhcHBlciB3aXRoIGVycm9yIGhhbmRsaW5nLCByZXRyaWVzLCBjaXJjdWl0IGJyZWFrZXIsIGFuZCBmYWxsYmFjayB0byBtb2NrIGRhdGFcbiAqIFxuICogRmVhdHVyZXM6XG4gKiAtIENpcmN1aXQgYnJlYWtlciBwYXR0ZXJuIHRvIHByZXZlbnQgY2FzY2FkaW5nIGZhaWx1cmVzXG4gKiAtIEV4cG9uZW50aWFsIGJhY2tvZmYgcmV0cnkgbWVjaGFuaXNtXG4gKiAtIFJlcXVlc3QgdGltZW91dCBoYW5kbGluZ1xuICogLSBHcmFjZWZ1bCBkZWdyYWRhdGlvbiB3aXRoIG1vY2sgZGF0YSBmYWxsYmFja3NcbiAqIC0gRGV0YWlsZWQgbG9nZ2luZyBmb3IgZGVidWdnaW5nXG4gKiBcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIEFQSSBlbmRwb2ludCB0byBmZXRjaCBmcm9tICh3aXRob3V0IGJhc2UgVVJMKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBGZXRjaCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9ja0RhdGFLZXkgLSBLZXkgdG8gYWNjZXNzIG1vY2sgZGF0YSBpZiBBUEkgZmFpbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXRyeUNvdW50IC0gQ3VycmVudCByZXRyeSBjb3VudCAodXNlZCBpbnRlcm5hbGx5KVxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gLSBQYXJzZWQgcmVzcG9uc2UgZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhFcnJvckhhbmRsaW5nKGVuZHBvaW50LCBvcHRpb25zID0ge30sIG1vY2tEYXRhS2V5ID0gbnVsbCwgcmV0cnlDb3VudCA9IDApIHtcbiAgY29uc3Qgc2VydmljZSA9ICdIRVJPS1VfQVBJJztcbiAgY29uc3QgZnVsbFVybCA9IGAke0FQSV9FTkRQT0lOVFMuSEVST0tVX0FQSX0ke2VuZHBvaW50fWA7XG4gIFxuICAvLyBDcmVhdGUgYSByZXF1ZXN0IElEIGZvciBsb2dnaW5nXG4gIGNvbnN0IHJlcXVlc3RJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gIFxuICAvLyBDaGVjayBjaXJjdWl0IGJyZWFrZXJcbiAgaWYgKGlzQ2lyY3VpdE9wZW4oc2VydmljZSkpIHtcbiAgICBjb25zb2xlLndhcm4oYFske3JlcXVlc3RJZH1dIENpcmN1aXQgb3BlbiBmb3IgJHtzZXJ2aWNlfSwgZmFsbGluZyBiYWNrIHRvIG1vY2sgZGF0YWApO1xuICAgIHJldHVybiBnZXRNb2NrRGF0YShlbmRwb2ludCwgbW9ja0RhdGFLZXkpO1xuICB9XG4gIFxuICAvLyBDcmVhdGUgQWJvcnRDb250cm9sbGVyIGZvciB0aW1lb3V0XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IG51bGw7XG4gIGNvbnN0IHRpbWVvdXREdXJhdGlvbiA9IG9wdGlvbnMudGltZW91dCB8fCBSRVFVRVNUX1RJTUVPVVRfTVM7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IGNvbnRyb2xsZXIgPyBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dER1cmF0aW9uKSA6IG51bGw7XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUuaW5mbyhgWyR7cmVxdWVzdElkfV0gRmV0Y2hpbmcgZnJvbSAke2Z1bGxVcmx9IChhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9LyR7TUFYX1JFVFJJRVMgKyAxfSlgKTtcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdYLVJlcXVlc3QtSUQnOiByZXF1ZXN0SWQsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgIH0sXG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgICBjcmVkZW50aWFsczogJ29taXQnLFxuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCB8fCBjb250cm9sbGVyPy5zaWduYWxcbiAgICB9KTtcblxuICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgc2V0XG4gICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIC8vIFJlY29yZCBzdWNjZXNzIGZvciBjaXJjdWl0IGJyZWFrZXJcbiAgICByZWNvcmRTdWNjZXNzKHNlcnZpY2UpO1xuICAgIFxuICAgIHJldHVybiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgc3RpbGwgYWN0aXZlXG4gICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgXG4gICAgLy8gSGFuZGxlIHRpbWVvdXQgZXJyb3JzIHNwZWNpZmljYWxseVxuICAgIGNvbnN0IGlzVGltZW91dCA9IGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJztcbiAgICBjb25zdCBlcnJvck1zZyA9IGlzVGltZW91dCBcbiAgICAgID8gYFJlcXVlc3QgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dER1cmF0aW9ufW1zYCBcbiAgICAgIDogZXJyb3IubWVzc2FnZTtcbiAgICBcbiAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSBBUEkgcmVxdWVzdCBmYWlsZWQgKGF0dGVtcHQgJHtyZXRyeUNvdW50ICsgMX0vJHtNQVhfUkVUUklFUyArIDF9KTogJHtlcnJvck1zZ31gKTtcbiAgICBcbiAgICAvLyBSZWNvcmQgZmFpbHVyZSBmb3IgY2lyY3VpdCBicmVha2VyXG4gICAgcmVjb3JkRmFpbHVyZShzZXJ2aWNlKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgcmV0cnlcbiAgICBpZiAocmV0cnlDb3VudCA8IE1BWF9SRVRSSUVTKSB7XG4gICAgICBjb25zdCBiYWNrb2ZmVGltZSA9IFJFVFJZX0JBQ0tPRkZfTVMgKiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAgICAgIGNvbnNvbGUuaW5mbyhgWyR7cmVxdWVzdElkfV0gUmV0cnlpbmcgaW4gJHtiYWNrb2ZmVGltZX1tcy4uLmApO1xuICAgICAgXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoZmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhlbmRwb2ludCwgb3B0aW9ucywgbW9ja0RhdGFLZXksIHJldHJ5Q291bnQgKyAxKSk7XG4gICAgICAgIH0sIGJhY2tvZmZUaW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsIGJhY2sgdG8gbW9jayBkYXRhIGFmdGVyIGFsbCByZXRyaWVzIGFyZSBleGhhdXN0ZWRcbiAgICBjb25zb2xlLndhcm4oYFske3JlcXVlc3RJZH1dIEFsbCByZXRyaWVzIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIG1vY2sgZGF0YWApO1xuICAgIHJldHVybiBnZXRNb2NrRGF0YShlbmRwb2ludCwgbW9ja0RhdGFLZXkpO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG1vY2sgZGF0YSBmb3IgYW4gZW5kcG9pbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIEFQSSBlbmRwb2ludFxuICogQHBhcmFtIHtzdHJpbmd9IG1vY2tEYXRhS2V5IC0gS2V5IHRvIGFjY2VzcyBtb2NrIGRhdGFcbiAqIEByZXR1cm5zIHthbnl9IC0gTW9jayBkYXRhXG4gKi9cbmZ1bmN0aW9uIGdldE1vY2tEYXRhKGVuZHBvaW50LCBtb2NrRGF0YUtleSkge1xuICAvLyBJZiB3ZSBoYXZlIG1vY2sgZGF0YSBmb3IgdGhpcyBrZXksIHJldHVybiBpdFxuICBpZiAobW9ja0RhdGFLZXkgJiYgTU9DS19EQVRBW21vY2tEYXRhS2V5XSkge1xuICAgIGNvbnNvbGUuaW5mbyhgVXNpbmcgbW9jayBkYXRhIGZvciAke2VuZHBvaW50fSB3aXRoIGtleSAke21vY2tEYXRhS2V5fWApO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGl0ZW0gcmVxdWVzdHNcbiAgICBpZiAoZW5kcG9pbnQuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgY29uc3QgcGFydHMgPSBlbmRwb2ludC5zcGxpdCgnLycpO1xuICAgICAgY29uc3QgaWQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlIG1vY2tEYXRhS2V5IHBvaW50cyB0byBhbiBhcnJheSwgZmluZCB0aGUgaXRlbSB3aXRoIG1hdGNoaW5nIElEXG4gICAgICBjb25zdCBpdGVtcyA9IE1PQ0tfREFUQVttb2NrRGF0YUtleV07XG4gICAgICBcbiAgICAgIGlmIChpdGVtcyAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXMuZmluZChpID0+IFN0cmluZyhpLmlkKSA9PT0gU3RyaW5nKGlkKSk7XG4gICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIE1PQ0tfREFUQVttb2NrRGF0YUtleV07XG4gIH1cbiAgXG4gIC8vIERlZmF1bHQgbW9jayBkYXRhIGZvciB1bmtub3duIGVuZHBvaW50c1xuICBpZiAoZW5kcG9pbnQuaW5jbHVkZXMoJ21vbGVjdWxlcycpKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoTU9DS19EQVRBLm1vbGVjdWxlcykgPyBNT0NLX0RBVEEubW9sZWN1bGVzWzBdIDogbnVsbDtcbiAgfSBlbHNlIGlmIChlbmRwb2ludC5pbmNsdWRlcygnbWl4dHVyZXMnKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KE1PQ0tfREFUQS5taXh0dXJlcykgPyBNT0NLX0RBVEEubWl4dHVyZXNbMF0gOiBudWxsO1xuICB9XG4gIFxuICAvLyBObyBtb2NrIGRhdGEgYXZhaWxhYmxlXG4gIHRocm93IG5ldyBFcnJvcihgTm8gbW9jayBkYXRhIGF2YWlsYWJsZSBmb3IgJHtlbmRwb2ludH1gKTtcbn1cblxuLyoqXG4gKiBGZXRjaCB3cmFwcGVyIGZvciBSREtpdCBBUEkgd2l0aCBjaXJjdWl0IGJyZWFrZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRwb2ludCAtIEFQSSBlbmRwb2ludCB0byBmZXRjaCBmcm9tIChlLmcuLCAnL2NhbGN1bGF0ZScsICcvZGVwaWN0JylcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gUmVxdWVzdCBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBmZXRjaCBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gcmV0cnlDb3VudCAtIEN1cnJlbnQgcmV0cnkgY291bnQgKHVzZWQgaW50ZXJuYWxseSlcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gUGFyc2VkIHJlc3BvbnNlIGRhdGFcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSREtpdEFQSShlbmRwb2ludCwgZGF0YSwgb3B0aW9ucyA9IHt9LCByZXRyeUNvdW50ID0gMCkge1xuICBjb25zdCBzZXJ2aWNlID0gJ1JES0lUX0FQSSc7XG4gIGNvbnN0IGZ1bGxVcmwgPSBgJHtBUElfRU5EUE9JTlRTLlJES0lUX0FQSX0ke2VuZHBvaW50fWA7XG4gIFxuICAvLyBDcmVhdGUgYSByZXF1ZXN0IElEIGZvciBsb2dnaW5nXG4gIGNvbnN0IHJlcXVlc3RJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCk7XG4gIFxuICAvLyBDaGVjayBjaXJjdWl0IGJyZWFrZXJcbiAgaWYgKGlzQ2lyY3VpdE9wZW4oc2VydmljZSkpIHtcbiAgICBjb25zb2xlLndhcm4oYFske3JlcXVlc3RJZH1dIENpcmN1aXQgb3BlbiBmb3IgJHtzZXJ2aWNlfWApO1xuICAgIHRocm93IG5ldyBFcnJvcihgUkRLaXQgc2VydmljZSB1bmF2YWlsYWJsZSAoY2lyY3VpdCBvcGVuKWApO1xuICB9XG4gIFxuICAvLyBDcmVhdGUgQWJvcnRDb250cm9sbGVyIGZvciB0aW1lb3V0XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IG51bGw7XG4gIGNvbnN0IHRpbWVvdXREdXJhdGlvbiA9IG9wdGlvbnMudGltZW91dCB8fCBSRVFVRVNUX1RJTUVPVVRfTVM7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IGNvbnRyb2xsZXIgPyBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dER1cmF0aW9uKSA6IG51bGw7XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUuaW5mbyhgWyR7cmVxdWVzdElkfV0gRmV0Y2hpbmcgZnJvbSAke2Z1bGxVcmx9IChhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9LyR7TUFYX1JFVFJJRVMgKyAxfSlgKTtcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZ1bGxVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnWC1SZXF1ZXN0LUlEJzogcmVxdWVzdElkLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCcsXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXI/LnNpZ25hbFxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgdGltZW91dFxuICAgIGlmICh0aW1lb3V0SWQpIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSREtpdCBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIC8vIFJlY29yZCBzdWNjZXNzXG4gICAgcmVjb3JkU3VjY2VzcyhzZXJ2aWNlKTtcbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2VEYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIENsZWFyIHRpbWVvdXQgaWYgc3RpbGwgYWN0aXZlXG4gICAgaWYgKHRpbWVvdXRJZCkgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgXG4gICAgLy8gSGFuZGxlIHRpbWVvdXQgZXJyb3JzIHNwZWNpZmljYWxseVxuICAgIGNvbnN0IGlzVGltZW91dCA9IGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJztcbiAgICBjb25zdCBlcnJvck1zZyA9IGlzVGltZW91dCBcbiAgICAgID8gYFJlcXVlc3QgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dER1cmF0aW9ufW1zYCBcbiAgICAgIDogZXJyb3IubWVzc2FnZTtcbiAgICBcbiAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSBSREtpdCBBUEkgcmVxdWVzdCBmYWlsZWQgKGF0dGVtcHQgJHtyZXRyeUNvdW50ICsgMX0vJHtNQVhfUkVUUklFUyArIDF9KTogJHtlcnJvck1zZ31gKTtcbiAgICBcbiAgICAvLyBSZWNvcmQgZmFpbHVyZVxuICAgIHJlY29yZEZhaWx1cmUoc2VydmljZSk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJldHJ5XG4gICAgaWYgKHJldHJ5Q291bnQgPCBNQVhfUkVUUklFUykge1xuICAgICAgY29uc3QgYmFja29mZlRpbWUgPSBSRVRSWV9CQUNLT0ZGX01TICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7XG4gICAgICBjb25zb2xlLmluZm8oYFske3JlcXVlc3RJZH1dIFJldHJ5aW5nIFJES2l0IEFQSSBpbiAke2JhY2tvZmZUaW1lfW1zLi4uYCk7XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShmZXRjaFJES2l0QVBJKGVuZHBvaW50LCBkYXRhLCBvcHRpb25zLCByZXRyeUNvdW50ICsgMSkpO1xuICAgICAgICB9LCBiYWNrb2ZmVGltZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYWxsIG1vbGVjdWxlc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBMaXN0IG9mIG1vbGVjdWxlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TW9sZWN1bGVzKCkge1xuICAvLyBDb252ZXggZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCBmb3IgbWluaW1hbCBkZXBsb3ltZW50XG4gIC8vIFdlJ2xsIGFsd2F5cyB1c2UgdGhlIFJFU1QgQVBJIG9yIG1vY2sgZGF0YVxuICBcbiAgLy8gRmFsbCBiYWNrIHRvIFJFU1QgQVBJXG4gIHJldHVybiBmZXRjaFdpdGhFcnJvckhhbmRsaW5nKCcvbW9sZWN1bGVzJywge30sICdtb2xlY3VsZXMnKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgbW9sZWN1bGUgYnkgSURcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaWQgLSBNb2xlY3VsZSBJRFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gTW9sZWN1bGUgZGF0YVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TW9sZWN1bGUoaWQpIHtcbiAgLy8gQ29udmV4IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQgZm9yIG1pbmltYWwgZGVwbG95bWVudFxuICAvLyBXZSdsbCBhbHdheXMgdXNlIHRoZSBSRVNUIEFQSSBvciBtb2NrIGRhdGFcbiAgXG4gIC8vIEZhbGwgYmFjayB0byBSRVNUIEFQSVxuICByZXR1cm4gZmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhgL21vbGVjdWxlcy8ke2lkfWAsIHt9LCAnbW9sZWN1bGVzJyk7XG59XG5cbi8qKlxuICogR2V0IGFsbCBtaXh0dXJlcyBcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5Pn0gTGlzdCBvZiBtaXh0dXJlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWl4dHVyZXMoKSB7XG4gIC8vIENvbnZleCBmdW5jdGlvbmFsaXR5IGRpc2FibGVkIGZvciBtaW5pbWFsIGRlcGxveW1lbnRcbiAgLy8gV2UnbGwgYWx3YXlzIHVzZSB0aGUgUkVTVCBBUEkgb3IgbW9jayBkYXRhXG4gIFxuICAvLyBGYWxsIGJhY2sgdG8gUkVTVCBBUElcbiAgcmV0dXJuIGZldGNoV2l0aEVycm9ySGFuZGxpbmcoJy9taXh0dXJlcycsIHt9LCAnbWl4dHVyZXMnKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBzaW5nbGUgbWl4dHVyZSBieSBJRFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCAtIE1peHR1cmUgSURcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IE1peHR1cmUgZGF0YVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TWl4dHVyZShpZCkge1xuICAvLyBDb252ZXggZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCBmb3IgbWluaW1hbCBkZXBsb3ltZW50XG4gIC8vIFdlJ2xsIGFsd2F5cyB1c2UgdGhlIFJFU1QgQVBJIG9yIG1vY2sgZGF0YVxuICBcbiAgLy8gRmFsbCBiYWNrIHRvIFJFU1QgQVBJXG4gIHJldHVybiBmZXRjaFdpdGhFcnJvckhhbmRsaW5nKGAvbWl4dHVyZXMvJHtpZH1gLCB7fSwgJ21peHR1cmVzJyk7XG59XG5cbi8qKlxuICogR2V0IFJES2l0IG1vbGVjdWxhciBwcm9wZXJ0aWVzIHdpdGggY2lyY3VpdCBicmVha2VyIGFuZCBmYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IHNtaWxlcyAtIFNNSUxFUyBub3RhdGlvbiBvZiB0aGUgbW9sZWN1bGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJES2l0IGNhbGN1bGF0aW9uIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJES2l0UHJvcGVydGllcyhzbWlsZXMpIHtcbiAgaWYgKCFzbWlsZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6ICdObyBTTUlMRVMgcHJvdmlkZWQnLFxuICAgICAgbW9sZWN1bGFyX3dlaWdodDogMCxcbiAgICAgIGxvZ3A6IDAsXG4gICAgICBudW1fYXRvbXM6IDAsXG4gICAgICBudW1fcmluZ3M6IDBcbiAgICB9O1xuICB9XG4gIFxuICB0cnkge1xuICAgIC8vIFJlcXVlc3QgcHJvcGVydGllcyBmcm9tIFJES2l0IHNlcnZpY2VcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hSREtpdEFQSSgnL2NhbGN1bGF0ZScsIHsgc21pbGVzIH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1JES2l0IHByb3BlcnRpZXMgY2FsY3VsYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBVc2UgZmFsbGJhY2sgcHJvcGVydHkgY2FsY3VsYXRpb25cbiAgICBpZiAoTU9DS19EQVRBLm1vbGVjdWxhcl9wcm9wZXJ0aWVzW3NtaWxlc10pIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhgVXNpbmcgcHJlLWNvbXB1dGVkIHByb3BlcnRpZXMgZm9yICR7c21pbGVzfWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uTU9DS19EQVRBLm1vbGVjdWxhcl9wcm9wZXJ0aWVzW3NtaWxlc10sXG4gICAgICAgIHNvdXJjZTogJ2ZhbGxiYWNrJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm8gcHJlLWNvbXB1dGVkIGRhdGEsIHVzZSByb3VnaCBlc3RpbWF0aW9uXG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbGVjdWxhcl93ZWlnaHQ6IGVzdGltYXRlTW9sZWN1bGFyV2VpZ2h0KHNtaWxlcyksXG4gICAgICBsb2dwOiAwLFxuICAgICAgbnVtX2F0b21zOiBjb3VudEF0b21zKHNtaWxlcyksXG4gICAgICBudW1fcmluZ3M6IGVzdGltYXRlUmluZ0NvdW50KHNtaWxlcyksXG4gICAgICBlcnJvcjogJ0ZhaWxlZCB0byBmZXRjaCBwcm9wZXJ0aWVzIGZyb20gUkRLaXQgc2VydmljZSwgdXNpbmcgZXN0aW1hdGVkIHZhbHVlcycsXG4gICAgICBzb3VyY2U6ICdlc3RpbWF0ZWQnXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgMkQgZGVwaWN0aW9uIG9mIGEgbW9sZWN1bGUgd2l0aCBjaXJjdWl0IGJyZWFrZXIgYW5kIGZhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gc21pbGVzIC0gU01JTEVTIG5vdGF0aW9uIG9mIHRoZSBtb2xlY3VsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25hbCByZW5kZXJpbmcgb3B0aW9ucyAod2lkdGgsIGhlaWdodCwgaW5jbHVkZU1vbGVjdWxlRGV0YWlscylcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFNWRyBkZXBpY3Rpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vbGVjdWxlRGVwaWN0aW9uKHNtaWxlcywgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghc21pbGVzKSByZXR1cm4gJyc7XG4gIFxuICBjb25zdCByZXF1ZXN0RGF0YSA9IHsgXG4gICAgc21pbGVzLCBcbiAgICB3aWR0aDogb3B0aW9ucy53aWR0aCB8fCAzMDAsIFxuICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfHwgMjAwLFxuICAgIGluY2x1ZGVNb2xlY3VsZURldGFpbHM6IG9wdGlvbnMuaW5jbHVkZU1vbGVjdWxlRGV0YWlscyB8fCBmYWxzZVxuICB9O1xuICBcbiAgdHJ5IHtcbiAgICAvLyBSZXF1ZXN0IGRlcGljdGlvbiBmcm9tIFJES2l0IHNlcnZpY2VcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hSREtpdEFQSSgnL2RlcGljdCcsIHJlcXVlc3REYXRhKTtcbiAgICByZXR1cm4gZGF0YS5zdmcgfHwgJyc7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUkRLaXQgZGVwaWN0aW9uIGdlbmVyYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBUcnkgdG8gdXNlIGNhY2hlZCBTVkcgZGVwaWN0aW9uIGlmIGF2YWlsYWJsZVxuICAgIGlmIChNT0NLX0RBVEEubW9sZWN1bGFyX2RlcGljdGlvbnNbc21pbGVzXSkge1xuICAgICAgY29uc29sZS5pbmZvKGBVc2luZyBjYWNoZWQgZGVwaWN0aW9uIGZvciAke3NtaWxlc31gKTtcbiAgICAgIHJldHVybiBNT0NLX0RBVEEubW9sZWN1bGFyX2RlcGljdGlvbnNbc21pbGVzXTtcbiAgICB9XG4gICAgXG4gICAgLy8gT3RoZXJ3aXNlIHJldHVybiBlbXB0eSBzdHJpbmcgdG8gc2hvdyBmYWxsYmFjayBVSVxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vKipcbiAqIFZlcnkgYmFzaWMgZXN0aW1hdGlvbiBvZiBtb2xlY3VsYXIgd2VpZ2h0IGZyb20gU01JTEVTIChmYWxsYmFjayBtZXRob2QpXG4gKiBUaGlzIGlzIGEgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9uIGFuZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gUkRLaXQgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzbWlsZXMgLSBTTUlMRVMgbm90YXRpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IEVzdGltYXRlZCBtb2xlY3VsYXIgd2VpZ2h0XG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlTW9sZWN1bGFyV2VpZ2h0KHNtaWxlcykge1xuICAvLyBUaGlzIGlzIGFuIGV4dHJlbWVseSBzaW1wbGlmaWVkIGFwcHJvYWNoXG4gIC8vIEEgcmVhbCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBuZWVkIHRvIHBhcnNlIHRoZSBTTUlMRVMgcHJvcGVybHlcbiAgXG4gIC8vIENvdW50IHNvbWUgY29tbW9uIGF0b21zXG4gIGNvbnN0IGNhcmJvbkNvdW50ID0gKHNtaWxlcy5tYXRjaCgvQy9nKSB8fCBbXSkubGVuZ3RoO1xuICBjb25zdCBoeWRyb2dlbkNvdW50ID0gKHNtaWxlcy5tYXRjaCgvSC9nKSB8fCBbXSkubGVuZ3RoO1xuICBjb25zdCBveHlnZW5Db3VudCA9IChzbWlsZXMubWF0Y2goL08vZykgfHwgW10pLmxlbmd0aDtcbiAgY29uc3Qgbml0cm9nZW5Db3VudCA9IChzbWlsZXMubWF0Y2goL04vZykgfHwgW10pLmxlbmd0aDtcbiAgY29uc3Qgc3VsZnVyQ291bnQgPSAoc21pbGVzLm1hdGNoKC9TL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGNvbnN0IHBob3NwaG9ydXNDb3VudCA9IChzbWlsZXMubWF0Y2goL1AvZykgfHwgW10pLmxlbmd0aDtcbiAgY29uc3QgZmx1b3JpbmVDb3VudCA9IChzbWlsZXMubWF0Y2goL0YvZykgfHwgW10pLmxlbmd0aDtcbiAgY29uc3QgY2hsb3JpbmVDb3VudCA9IChzbWlsZXMubWF0Y2goL0NsL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGNvbnN0IGJyb21pbmVDb3VudCA9IChzbWlsZXMubWF0Y2goL0JyL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGNvbnN0IGlvZGluZUNvdW50ID0gKHNtaWxlcy5tYXRjaCgvSS9nKSB8fCBbXSkubGVuZ3RoO1xuICBcbiAgLy8gQXBwcm94aW1hdGUgd2VpZ2h0c1xuICBjb25zdCBDX1dFSUdIVCA9IDEyLjAxO1xuICBjb25zdCBIX1dFSUdIVCA9IDEuMDE7XG4gIGNvbnN0IE9fV0VJR0hUID0gMTYuMDA7XG4gIGNvbnN0IE5fV0VJR0hUID0gMTQuMDE7XG4gIGNvbnN0IFNfV0VJR0hUID0gMzIuMDc7XG4gIGNvbnN0IFBfV0VJR0hUID0gMzAuOTc7XG4gIGNvbnN0IEZfV0VJR0hUID0gMTkuMDA7XG4gIGNvbnN0IENMX1dFSUdIVCA9IDM1LjQ1O1xuICBjb25zdCBCUl9XRUlHSFQgPSA3OS45MDtcbiAgY29uc3QgSV9XRUlHSFQgPSAxMjYuOTA7XG4gIFxuICAvLyBSb3VnaCBlc3RpbWF0ZSBvZiB3ZWlnaHQgZnJvbSBhdG9tIGNvdW50c1xuICBjb25zdCB3ZWlnaHQgPSAoXG4gICAgY2FyYm9uQ291bnQgKiBDX1dFSUdIVCArIFxuICAgIGh5ZHJvZ2VuQ291bnQgKiBIX1dFSUdIVCArIFxuICAgIG94eWdlbkNvdW50ICogT19XRUlHSFQgKyBcbiAgICBuaXRyb2dlbkNvdW50ICogTl9XRUlHSFQgK1xuICAgIHN1bGZ1ckNvdW50ICogU19XRUlHSFQgK1xuICAgIHBob3NwaG9ydXNDb3VudCAqIFBfV0VJR0hUICtcbiAgICBmbHVvcmluZUNvdW50ICogRl9XRUlHSFQgK1xuICAgIGNobG9yaW5lQ291bnQgKiBDTF9XRUlHSFQgK1xuICAgIGJyb21pbmVDb3VudCAqIEJSX1dFSUdIVCArXG4gICAgaW9kaW5lQ291bnQgKiBJX1dFSUdIVFxuICApO1xuICBcbiAgLy8gQWRkIGFuIGVzdGltYXRlIGZvciBpbXBsaWNpdCBoeWRyb2dlbnNcbiAgLy8gVGhpcyBpcyBhIHZlcnkgcm91Z2ggaGV1cmlzdGljXG4gIGNvbnN0IGltcGxpY2l0SHlkcm9nZW5zID0gTWF0aC5tYXgoMCwgY2FyYm9uQ291bnQgKiAyKTtcbiAgXG4gIHJldHVybiBNYXRoLnJvdW5kKCh3ZWlnaHQgKyBpbXBsaWNpdEh5ZHJvZ2VucyAqIEhfV0VJR0hUKSAqIDEwMCkgLyAxMDA7XG59XG5cbi8qKlxuICogQ291bnQgYXRvbXMgaW4gU01JTEVTIChmYWxsYmFjayBtZXRob2QpXG4gKiBAcGFyYW0ge3N0cmluZ30gc21pbGVzIC0gU01JTEVTIG5vdGF0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBBcHByb3hpbWF0ZSBhdG9tIGNvdW50XG4gKi9cbmZ1bmN0aW9uIGNvdW50QXRvbXMoc21pbGVzKSB7XG4gIC8vIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsaWZpZWQgYXBwcm9hY2hcbiAgLy8gV2UnbGwgY291bnQgdGhlIHVwcGVyY2FzZSBsZXR0ZXJzIGFzIGEgcm91Z2ggcHJveHkgZm9yIGF0b21zXG4gIC8vIFdlJ2xsIGFsc28gY2hlY2sgZm9yIHNvbWUgY29tbW9uIHR3by1sZXR0ZXIgYXRvbXNcbiAgXG4gIC8vIEJhc2ljIHBhdHRlcm4gZm9yIGFueSBhdG9tIHN5bWJvbCAodXBwZXJjYXNlIGxldHRlciBwb3NzaWJseSBmb2xsb3dlZCBieSBsb3dlcmNhc2UgbGV0dGVyKVxuICBjb25zdCBhdG9tUGF0dGVybiA9IC9bQS1aXVthLXpdPy9nO1xuICBjb25zdCBtYXRjaGVzID0gc21pbGVzLm1hdGNoKGF0b21QYXR0ZXJuKSB8fCBbXTtcbiAgXG4gIHJldHVybiBtYXRjaGVzLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgbnVtYmVyIG9mIHJpbmdzIGluIGEgbW9sZWN1bGUgZnJvbSBTTUlMRVNcbiAqIFRoaXMgaXMgYSB2ZXJ5IGJhc2ljIGhldXJpc3RpYyBmb3Igd2hlbiBSREtpdCBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IHNtaWxlcyAtIFNNSUxFUyBub3RhdGlvblxuICogQHJldHVybnMge251bWJlcn0gQXBwcm94aW1hdGUgcmluZyBjb3VudFxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZVJpbmdDb3VudChzbWlsZXMpIHtcbiAgLy8gTG9vayBmb3IgZGlnaXQgcGFpcnMgd2hpY2ggaW5kaWNhdGUgcmluZyBjbG9zdXJlcyBpbiBTTUlMRVNcbiAgY29uc3QgcmluZ0RpZ2l0cyA9IHNtaWxlcy5tYXRjaCgvXFxkL2cpIHx8IFtdO1xuICBcbiAgLy8gRWFjaCByaW5nIHNob3VsZCBiZSBjb3VudGVkIG9uY2UgKHR3byBkaWdpdHMgcGVyIHJpbmcpXG4gIHJldHVybiBNYXRoLmZsb29yKHJpbmdEaWdpdHMubGVuZ3RoIC8gMik7XG59XG5cbi8qKlxuICogQ2hlY2sgQ29udmV4IGNvbm5lY3Rpb24gc3RhdHVzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gVHJ1ZSBpZiBDb252ZXggaXMgY29ubmVjdGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0NvbnZleENvbm5lY3Rpb24oKSB7XG4gIC8vIENvbnZleCBmdW5jdGlvbmFsaXR5IGRpc2FibGVkIGZvciBtaW5pbWFsIGRlcGxveW1lbnRcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBtb2xlY3VsZSB1c2luZyBDb252ZXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2xlY3VsZURhdGEgLSBEYXRhIGZvciB0aGUgbmV3IG1vbGVjdWxlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkTW9sZWN1bGUobW9sZWN1bGVEYXRhKSB7XG4gIC8vIENvbnZleCBmdW5jdGlvbmFsaXR5IGRpc2FibGVkIGZvciBtaW5pbWFsIGRlcGxveW1lbnRcbiAgdGhyb3cgbmV3IEVycm9yKCdBZGRpbmcgbW9sZWN1bGVzIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBtaW5pbWFsIGRlcGxveW1lbnQnKTtcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBtb2xlY3VsZSB1c2luZyBDb252ZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIElEIG9mIHRoZSBtb2xlY3VsZSB0byBkZWxldGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVNb2xlY3VsZShpZCkge1xuICAvLyBDb252ZXggZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCBmb3IgbWluaW1hbCBkZXBsb3ltZW50XG4gIHRocm93IG5ldyBFcnJvcignRGVsZXRpbmcgbW9sZWN1bGVzIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBtaW5pbWFsIGRlcGxveW1lbnQnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXRNb2xlY3VsZXMsXG4gIGdldE1vbGVjdWxlLFxuICBnZXRNaXh0dXJlcyxcbiAgZ2V0TWl4dHVyZSxcbiAgZ2V0UkRLaXRQcm9wZXJ0aWVzLFxuICBnZXRNb2xlY3VsZURlcGljdGlvbixcbiAgY2hlY2tDb252ZXhDb25uZWN0aW9uLFxuICBhZGRNb2xlY3VsZSxcbiAgZGVsZXRlTW9sZWN1bGVcbn07Il0sIm5hbWVzIjpbIkFQSV9FTkRQT0lOVFMiLCJIRVJPS1VfQVBJIiwiUkRLSVRfQVBJIiwiQ09OVkVYIiwiVVNFX0NPTlZFWCIsIk1PQ0tfREFUQSIsIm1vbGVjdWxlcyIsImlkIiwibmFtZSIsImZvcm11bGEiLCJwdWJjaGVtX2NpZCIsInNtaWxlcyIsIm1vbGVjdWxhcl93ZWlnaHQiLCJpc19jcnlvcHJvdGVjdGFudCIsImRlc2NyaXB0aW9uIiwibWl4dHVyZXMiLCJjb21wb25lbnRzIiwibW9sZWN1bGUiLCJjb25jZW50cmF0aW9uIiwiY29uY2VudHJhdGlvbl91bml0Iiwicm9sZSIsIm1vbGVjdWxhcl9kZXBpY3Rpb25zIiwibW9sZWN1bGFyX3Byb3BlcnRpZXMiLCJsb2dwIiwibnVtX2F0b21zIiwibnVtX3JpbmdzIiwiaXNCcm93c2VyIiwiY2lyY3VpdEJyZWFrZXIiLCJmYWlsdXJlQ291bnQiLCJsYXN0RmFpbHVyZVRpbWUiLCJzdGF0ZSIsImxhc3RTdWNjZXNzVGltZSIsIkRhdGUiLCJub3ciLCJDSVJDVUlUX0JSRUFLRVJfVEhSRVNIT0xEIiwiQ0lSQ1VJVF9CUkVBS0VSX1RJTUVPVVQiLCJNQVhfUkVUUklFUyIsIlJFVFJZX0JBQ0tPRkZfTVMiLCJSRVFVRVNUX1RJTUVPVVRfTVMiLCJpc0NpcmN1aXRPcGVuIiwic2VydmljZSIsImJyZWFrZXIiLCJjb25zb2xlIiwiaW5mbyIsInJlY29yZFN1Y2Nlc3MiLCJyZWNvcmRGYWlsdXJlIiwid2FybiIsImZldGNoV2l0aEVycm9ySGFuZGxpbmciLCJlbmRwb2ludCIsIm9wdGlvbnMiLCJtb2NrRGF0YUtleSIsInJldHJ5Q291bnQiLCJmdWxsVXJsIiwicmVxdWVzdElkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZ2V0TW9ja0RhdGEiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dER1cmF0aW9uIiwidGltZW91dCIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwibW9kZSIsImNyZWRlbnRpYWxzIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsImVycm9yIiwiaXNUaW1lb3V0IiwiZXJyb3JNc2ciLCJtZXNzYWdlIiwiYmFja29mZlRpbWUiLCJwb3ciLCJQcm9taXNlIiwicmVzb2x2ZSIsImluY2x1ZGVzIiwicGFydHMiLCJzcGxpdCIsImxlbmd0aCIsIml0ZW1zIiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbSIsImZpbmQiLCJpIiwiU3RyaW5nIiwiZmV0Y2hSREtpdEFQSSIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2VEYXRhIiwiZ2V0TW9sZWN1bGVzIiwiZ2V0TW9sZWN1bGUiLCJnZXRNaXh0dXJlcyIsImdldE1peHR1cmUiLCJnZXRSREtpdFByb3BlcnRpZXMiLCJzb3VyY2UiLCJlc3RpbWF0ZU1vbGVjdWxhcldlaWdodCIsImNvdW50QXRvbXMiLCJlc3RpbWF0ZVJpbmdDb3VudCIsImdldE1vbGVjdWxlRGVwaWN0aW9uIiwicmVxdWVzdERhdGEiLCJ3aWR0aCIsImhlaWdodCIsImluY2x1ZGVNb2xlY3VsZURldGFpbHMiLCJzdmciLCJjYXJib25Db3VudCIsIm1hdGNoIiwiaHlkcm9nZW5Db3VudCIsIm94eWdlbkNvdW50Iiwibml0cm9nZW5Db3VudCIsInN1bGZ1ckNvdW50IiwicGhvc3Bob3J1c0NvdW50IiwiZmx1b3JpbmVDb3VudCIsImNobG9yaW5lQ291bnQiLCJicm9taW5lQ291bnQiLCJpb2RpbmVDb3VudCIsIkNfV0VJR0hUIiwiSF9XRUlHSFQiLCJPX1dFSUdIVCIsIk5fV0VJR0hUIiwiU19XRUlHSFQiLCJQX1dFSUdIVCIsIkZfV0VJR0hUIiwiQ0xfV0VJR0hUIiwiQlJfV0VJR0hUIiwiSV9XRUlHSFQiLCJ3ZWlnaHQiLCJpbXBsaWNpdEh5ZHJvZ2VucyIsIm1heCIsInJvdW5kIiwiYXRvbVBhdHRlcm4iLCJtYXRjaGVzIiwicmluZ0RpZ2l0cyIsImZsb29yIiwiY2hlY2tDb252ZXhDb25uZWN0aW9uIiwiYWRkTW9sZWN1bGUiLCJtb2xlY3VsZURhdGEiLCJkZWxldGVNb2xlY3VsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/api.js\n"));

/***/ })

});