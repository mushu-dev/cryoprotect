#!/usr/bin/env python3
"""
Direct PostgreSQL adapter implementation for CryoProtect v2.

This module provides a direct connection adapter for PostgreSQL databases
with DNS/IP resolution fallback.
"""

import os
import logging
import socket
import time
import json
import psycopg2
from psycopg2.pool import ThreadedConnectionPool
from psycopg2.extras import RealDictCursor
from typing import Any, Dict, List, Optional, Union, Tuple
import subprocess

from ..connection import ConnectionAdapter, generate_connection_request_id

# Import from the new configuration system
from ..connection_config import (
    validate_config,
    get_connection_config,
    # Supabase configuration (used for direct adapter)
    DATABASE_SUPABASE_HOST,
    DATABASE_SUPABASE_PORT,
    DATABASE_SUPABASE_DATABASE,
    DATABASE_SUPABASE_USER,
    DATABASE_SUPABASE_PASSWORD,
    DATABASE_SUPABASE_IP_ADDRESS,
    DATABASE_SUPABASE_MIN_CONNECTIONS,
    DATABASE_SUPABASE_MAX_CONNECTIONS,
    # Common configuration
    DATABASE_APPLICATION_NAME,
    DATABASE_CONNECTION_TIMEOUT,
    DATABASE_CONNECTION_LIFETIME,
    DATABASE_IDLE_TIMEOUT
)

logger = logging.getLogger(__name__)

class DirectAdapter(ConnectionAdapter):
    """
    Direct PostgreSQL database adapter implementation.
    
    This adapter provides direct connection to a PostgreSQL database
    with DNS/IP resolution fallback for improved reliability.
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize adapter with configuration.
        
        Args:
            config: Dictionary containing connection parameters
        """
        # Merge provided config with default configuration values
        # This ensures backward compatibility and allows for overrides
        self.config = {
            'host': DATABASE_SUPABASE_HOST,
            'port': DATABASE_SUPABASE_PORT,
            'database': DATABASE_SUPABASE_DATABASE,
            'user': DATABASE_SUPABASE_USER,
            'password': DATABASE_SUPABASE_PASSWORD,
            'ip_address': DATABASE_SUPABASE_IP_ADDRESS,
            'min_connections': DATABASE_SUPABASE_MIN_CONNECTIONS,
            'max_connections': DATABASE_SUPABASE_MAX_CONNECTIONS,
            'application_name': DATABASE_APPLICATION_NAME,
            'connection_timeout': DATABASE_CONNECTION_TIMEOUT,
            'connection_lifetime': DATABASE_CONNECTION_LIFETIME,
            'idle_timeout': DATABASE_IDLE_TIMEOUT
        }
        
        # Override defaults with provided values
        if config:
            self.config.update(config)
            
        self.connection_pool = None
        self.ip_address = self.config.get('ip_address')
        
    def _resolve_hostname(self, hostname: str) -> Optional[str]:
        """
        Resolve hostname to IP address with multiple methods.
        
        Args:
            hostname: Hostname to resolve
            
        Returns:
            IP address or None if resolution fails
        """
        request_id = generate_connection_request_id()
        logger.debug("[ConnReq:%s] Attempting to resolve hostname '%s'", request_id, hostname)
        
        methods = [
            self._resolve_with_socket,
            self._resolve_with_nslookup,
            self._resolve_with_dig,
            self._resolve_with_alternative_dns
        ]
        
        for method in methods:
            try:
                ip = method(hostname)
                if ip:
                    logger.info("[ConnReq:%s] Resolved %s to %s using %s", 
                               request_id, hostname, ip, method.__name__)
                    return ip
            except Exception as e:
                logger.debug("[ConnReq:%s] Failed to resolve %s using %s: %s", 
                            request_id, hostname, method.__name__, str(e))
                
        logger.warning("[ConnReq:%s] Failed to resolve hostname '%s' using any method", 
                      request_id, hostname)
        return None
        
    def _resolve_with_socket(self, hostname: str) -> Optional[str]:
        """Resolve hostname using socket."""
        try:
            return socket.gethostbyname(hostname)
        except:
            return None
            
    def _resolve_with_nslookup(self, hostname: str) -> Optional[str]:
        """Resolve hostname using nslookup."""
        try:
            output = subprocess.check_output(["nslookup", hostname], universal_newlines=True)
            for line in output.splitlines():
                if "Address:" in line and not "localhost" in line:
                    return line.split("Address:")[1].strip()
            return None
        except:
            return None
            
    def _resolve_with_dig(self, hostname: str) -> Optional[str]:
        """Resolve hostname using dig."""
        try:
            output = subprocess.check_output(["dig", "+short", hostname], universal_newlines=True)
            if output:
                return output.strip()
            return None
        except:
            return None
            
    def _resolve_with_alternative_dns(self, hostname: str) -> Optional[str]:
        """Resolve hostname using alternative DNS servers."""
        dns_servers = ["8.8.8.8", "1.1.1.1", "9.9.9.9"]
        
        for dns in dns_servers:
            try:
                output = subprocess.check_output(
                    ["nslookup", hostname, dns],
                    universal_newlines=True
                )
                for line in output.splitlines():
                    if "Address:" in line and not dns in line and not "localhost" in line:
                        return line.split("Address:")[1].strip()
            except:
                continue
                
        return None
        
    def connect(self) -> bool:
        """
        Establish connection pool to PostgreSQL.
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        request_id = generate_connection_request_id()
        logger.info("[ConnReq:%s] Attempting to connect to PostgreSQL with direct connection", request_id)
        
        start_time = time.time()
        
        try:
            # Extract connection parameters
            host = self.config.get('host', DATABASE_SUPABASE_HOST)
            port = self.config.get('port', DATABASE_SUPABASE_PORT)
            dbname = self.config.get('database', DATABASE_SUPABASE_DATABASE)
            user = self.config.get('user', DATABASE_SUPABASE_USER)
            password = self.config.get('password', DATABASE_SUPABASE_PASSWORD)
            min_conn = int(self.config.get('min_connections', DATABASE_SUPABASE_MIN_CONNECTIONS))
            max_conn = int(self.config.get('max_connections', DATABASE_SUPABASE_MAX_CONNECTIONS))
            application_name = self.config.get('application_name', DATABASE_APPLICATION_NAME)
            connection_timeout = int(self.config.get('connection_timeout', DATABASE_CONNECTION_TIMEOUT))
            
            # Log connection attempt (without password)
            logger.debug("[ConnReq:%s] Connection parameters: host=%s, port=%s, dbname=%s, user=%s, min_conn=%d, max_conn=%d",
                        request_id, host, port, dbname, user, min_conn, max_conn)
            
            if not host or not user or not password:
                logger.error("[ConnReq:%s] Missing required connection parameters", request_id)
                return False
                
            # Base connection parameters
            connect_params = {
                'port': port,
                'dbname': dbname,
                'user': user,
                'password': password,
                'application_name': application_name,
                'connect_timeout': connection_timeout
            }
            
            # Try direct hostname connection
            try:
                logger.info("[ConnReq:%s] Trying direct hostname connection to %s", request_id, host)
                connect_start = time.time()
                
                # Add host to connect params
                connect_params['host'] = host
                
                self.connection_pool = ThreadedConnectionPool(
                    minconn=min_conn,
                    maxconn=max_conn,
                    **connect_params
                )
                
                connect_duration = time.time() - connect_start
                logger.info("[ConnReq:%s] Connected to PostgreSQL at %s:%s/%s (duration=%.3fs)",
                           request_id, host, port, dbname, connect_duration)
                
                # Verify connection by running a test query
                test_start = time.time()
                success, message = self.test_connection()
                test_duration = time.time() - test_start
                
                if success:
                    logger.info("[ConnReq:%s] Connection test successful (duration=%.3fs): %s",
                               request_id, test_duration, message)
                    
                    total_duration = time.time() - start_time
                    logger.info("[ConnReq:%s] Successfully connected to PostgreSQL (total_duration=%.3fs)",
                               request_id, total_duration)
                    return True
                else:
                    logger.warning("[ConnReq:%s] Connection test failed: %s", request_id, message)
                    self.connection_pool = None
            except (psycopg2.OperationalError, socket.gaierror) as e:
                logger.warning("[ConnReq:%s] Failed to connect with hostname: %s", request_id, str(e))
                
                # Close pool if it was created
                if self.connection_pool:
                    try:
                        self.connection_pool.closeall()
                    except:
                        pass
                    self.connection_pool = None
                
            # If we have an IP address in config, use it directly
            if self.ip_address:
                logger.info("[ConnReq:%s] Using pre-configured IP address: %s", request_id, self.ip_address)
            else:
                # Resolve hostname to IP
                logger.info("[ConnReq:%s] Attempting to resolve hostname %s to IP", request_id, host)
                self.ip_address = self._resolve_hostname(host)
                
            if not self.ip_address:
                logger.error("[ConnReq:%s] Failed to resolve hostname %s to IP address", request_id, host)
                return False
                
            # Try connection with IP address
            try:
                logger.info("[ConnReq:%s] Trying IP address connection to %s", request_id, self.ip_address)
                connect_start = time.time()
                
                # Update host in connect params
                connect_params['host'] = self.ip_address
                
                self.connection_pool = ThreadedConnectionPool(
                    minconn=min_conn,
                    maxconn=max_conn,
                    **connect_params
                )
                
                connect_duration = time.time() - connect_start
                logger.info("[ConnReq:%s] Connected to PostgreSQL at %s:%s/%s (IP fallback) (duration=%.3fs)",
                           request_id, self.ip_address, port, dbname, connect_duration)
                
                # Verify connection by running a test query
                test_start = time.time()
                success, message = self.test_connection()
                test_duration = time.time() - test_start
                
                if success:
                    logger.info("[ConnReq:%s] Connection test successful (duration=%.3fs): %s",
                               request_id, test_duration, message)
                    
                    total_duration = time.time() - start_time
                    logger.info("[ConnReq:%s] Successfully connected to PostgreSQL with IP fallback (total_duration=%.3fs)",
                               request_id, total_duration)
                    return True
                else:
                    logger.warning("[ConnReq:%s] Connection test failed with IP fallback: %s", request_id, message)
                    self.connection_pool = None
                    return False
            except Exception as e2:
                total_duration = time.time() - start_time
                logger.error("[ConnReq:%s] Failed to connect with IP fallback: %s (duration=%.3fs)",
                            request_id, str(e2), total_duration)
                return False
        except Exception as e:
            total_duration = time.time() - start_time
            logger.error("[ConnReq:%s] Failed to connect to PostgreSQL: %s (duration=%.3fs)",
                        request_id, str(e), total_duration)
            return False
            
    def disconnect(self) -> bool:
        """
        Close all connections in the pool.
        
        Returns:
            bool: True if disconnection successful, False otherwise
        """
        request_id = generate_connection_request_id()
        logger.info("[ConnReq:%s] Disconnecting from PostgreSQL", request_id)
        
        start_time = time.time()
        
        if not self.connection_pool:
            logger.debug("[ConnReq:%s] No active connection pool to disconnect", request_id)
            return True
            
        try:
            # Get connection pool stats before closing
            try:
                used_connections = len(self.connection_pool._used)
                unused_connections = len(self.connection_pool._unused)
                total_connections = used_connections + unused_connections
                
                logger.debug("[ConnReq:%s] Connection pool stats before disconnect: used=%d, unused=%d, total=%d",
                            request_id, used_connections, unused_connections, total_connections)
            except Exception as stats_error:
                logger.debug("[ConnReq:%s] Could not get connection pool stats: %s",
                            request_id, str(stats_error))
                
            # Close all connections
            self.connection_pool.closeall()
            
            duration = time.time() - start_time
            logger.info("[ConnReq:%s] Successfully disconnected from PostgreSQL (duration=%.3fs)",
                       request_id, duration)
            
            self.connection_pool = None
            return True
        except Exception as e:
            duration = time.time() - start_time
            logger.error("[ConnReq:%s] Failed to disconnect from PostgreSQL (duration=%.3fs): %s",
                        request_id, duration, str(e))
            return False
            
    def reconnect(self) -> bool:
        """
        Re-establish a dropped connection to the database.
        
        This method will close any existing connection resources
        and then attempt to establish a new connection with DNS/IP fallback.
        
        Returns:
            bool: True if reconnection successful, False otherwise
        """
        request_id = generate_connection_request_id()
        logger.info("[ConnReq:%s] Attempting to reconnect to PostgreSQL with direct connection", request_id)
        
        start_time = time.time()
        
        # First, ensure any existing connections are properly closed
        try:
            if self.connection_pool:
                # Get connection pool stats before closing
                try:
                    used_connections = len(self.connection_pool._used)
                    unused_connections = len(self.connection_pool._unused)
                    total_connections = used_connections + unused_connections
                    
                    logger.debug("[ConnReq:%s] Connection pool stats before reconnect: used=%d, unused=%d, total=%d",
                                request_id, used_connections, unused_connections, total_connections)
                except Exception as stats_error:
                    logger.debug("[ConnReq:%s] Could not get connection pool stats: %s",
                                request_id, str(stats_error))
                
                close_start = time.time()
                self.connection_pool.closeall()
                close_duration = time.time() - close_start
                
                logger.info("[ConnReq:%s] Closed existing connection pool (duration=%.3fs)",
                           request_id, close_duration)
        except Exception as e:
            logger.warning("[ConnReq:%s] Error closing existing connection pool: %s",
                          request_id, str(e))
        
        # Set connection pool to None to ensure we create a new one
        self.connection_pool = None
        
        # Reset IP address to force DNS resolution again if needed
        # This helps if the IP address has changed or if DNS issues were temporary
        # Only reset if it wasn't explicitly provided in config
        if not self.config.get('ip_address'):
            self.ip_address = None
            logger.debug("[ConnReq:%s] Reset IP address for reconnection", request_id)
        
        # Attempt to establish a new connection
        connect_start = time.time()
        result = self.connect()
        connect_duration = time.time() - connect_start
        
        total_duration = time.time() - start_time
        
        if result:
            logger.info("[ConnReq:%s] Successfully reconnected to PostgreSQL (total_duration=%.3fs)",
                       request_id, total_duration)
        else:
            logger.error("[ConnReq:%s] Failed to reconnect to PostgreSQL (total_duration=%.3fs)",
                        request_id, total_duration)
        
        return result
            
    def execute_query(self, query: str, params: Optional[Union[Tuple, Dict]] = None) -> Any:
        """
        Execute SQL query and return results.
        
        Args:
            query: SQL query to execute
            params: Query parameters
            
        Returns:
            Query results
        """
        conn = None
        try:
            conn = self.connection_pool.getconn()
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute(query, params)
                
                if query.strip().upper().startswith('SELECT') or 'RETURNING' in query.upper():
                    result = cursor.fetchall()
                    return result
                else:
                    conn.commit()
                    return cursor.rowcount
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"Error executing query: {str(e)}")
            raise
        finally:
            if conn:
                self.connection_pool.putconn(conn)
                
    def execute_batch(self, queries: List[str]) -> List[Any]:
        """
        Execute multiple SQL queries and return results.
        
        Args:
            queries: List of SQL queries to execute
            
        Returns:
            List of query results
        """
        conn = None
        results = []
        
        try:
            conn = self.connection_pool.getconn()
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                for query in queries:
                    cursor.execute(query)
                    
                    if query.strip().upper().startswith('SELECT') or 'RETURNING' in query.upper():
                        results.append(cursor.fetchall())
                    else:
                        conn.commit()
                        results.append(cursor.rowcount)
                        
            return results
        except Exception as e:
            if conn:
                conn.rollback()
            logger.error(f"Error executing batch: {str(e)}")
            raise
        finally:
            if conn:
                self.connection_pool.putconn(conn)
                
    def begin_transaction(self) -> Any:
        """
        Begin a database transaction.
        
        Returns:
            Connection object representing the transaction
        """
        try:
            conn = self.connection_pool.getconn()
            conn.autocommit = False
            return conn
        except Exception as e:
            logger.error(f"Error beginning transaction: {str(e)}")
            raise
            
    def commit_transaction(self, transaction: Any) -> bool:
        """
        Commit a database transaction.
        
        Args:
            transaction: Connection object representing the transaction
            
        Returns:
            bool: True if commit successful, False otherwise
        """
        try:
            transaction.commit()
            self.connection_pool.putconn(transaction)
            return True
        except Exception as e:
            logger.error(f"Error committing transaction: {str(e)}")
            return False
            
    def rollback_transaction(self, transaction: Any) -> bool:
        """
        Rollback a database transaction.
        
        Args:
            transaction: Connection object representing the transaction
            
        Returns:
            bool: True if rollback successful, False otherwise
        """
        try:
            transaction.rollback()
            self.connection_pool.putconn(transaction)
            return True
        except Exception as e:
            logger.error(f"Error rolling back transaction: {str(e)}")
            return False
            
    def get_connection_info(self) -> Dict[str, Any]:
        """
        Get connection information.
        
        Returns:
            Dict with connection information
        """
        return {
            'type': 'direct',
            'host': self.config.get('host', DATABASE_SUPABASE_HOST),
            'ip_address': self.ip_address,
            'port': self.config.get('port', DATABASE_SUPABASE_PORT),
            'database': self.config.get('database', DATABASE_SUPABASE_DATABASE),
            'user': self.config.get('user', DATABASE_SUPABASE_USER),
            'pool_min_size': self.config.get('min_connections', DATABASE_SUPABASE_MIN_CONNECTIONS),
            'pool_max_size': self.config.get('max_connections', DATABASE_SUPABASE_MAX_CONNECTIONS),
            'application_name': self.config.get('application_name', DATABASE_APPLICATION_NAME),
            'connection_timeout': self.config.get('connection_timeout', DATABASE_CONNECTION_TIMEOUT),
            'connection_lifetime': self.config.get('connection_lifetime', DATABASE_CONNECTION_LIFETIME),
            'connected': self.connection_pool is not None
        }
        
    def test_connection(self) -> Tuple[bool, str]:
        """
        Test database connection and return status with message.
        
        Returns:
            Tuple of (success: bool, message: str)
        """
        request_id = generate_connection_request_id()
        logger.debug("[ConnReq:%s] Testing direct PostgreSQL connection", request_id)
        
        start_time = time.time()
        
        if not self.connection_pool:
            duration = time.time() - start_time
            logger.warning("[ConnReq:%s] Connection test failed: No connection pool exists (duration=%.3fs)",
                          request_id, duration)
            return False, "No connection pool exists"
        
        try:
            query_start = time.time()
            result = self.execute_query("SELECT 1 as test")
            query_duration = time.time() - query_start
            
            if result and result[0]['test'] == 1:
                duration = time.time() - start_time
                logger.debug("[ConnReq:%s] Connection test successful (duration=%.3fs, query_time=%.3fs)",
                            request_id, duration, query_duration)
                return True, "Connection successful"
            else:
                duration = time.time() - start_time
                logger.warning("[ConnReq:%s] Connection test failed: Unexpected result (duration=%.3fs)",
                              request_id, duration)
                return False, "Connection test failed: Unexpected result"
        except psycopg2.OperationalError as e:
            duration = time.time() - start_time
            logger.error("[ConnReq:%s] Connection test failed: Operational error (duration=%.3fs): %s",
                        request_id, duration, str(e))
            return False, f"Connection operational error: {str(e)}"
        except Exception as e:
            duration = time.time() - start_time
            logger.error("[ConnReq:%s] Connection test failed: Unexpected error (duration=%.3fs): %s",
                        request_id, duration, str(e))
            return False, f"Connection error: {str(e)}"
            
    def is_healthy(self) -> Tuple[bool, Dict[str, Any]]:
        """
        Perform a comprehensive health check on the database connection.
        
        This method checks various aspects of the connection health:
        - Basic connectivity
        - Connection latency
        - Transaction capability
        - Query execution capability
        - Connection pool status
        - DNS resolution status
        
        Returns:
            Tuple of (healthy: bool, health_metrics: Dict[str, Any])
        """
        request_id = generate_connection_request_id()
        logger.info("[ConnReq:%s] Performing comprehensive health check on direct PostgreSQL connection",
                   request_id)
        
        health_check_start = time.time()
        
        metrics = {
            'basic_connectivity': False,
            'latency_ms': None,
            'transaction_capability': False,
            'query_capability': False,
            'dns_resolution': {
                'hostname': self.config.get('host', DATABASE_SUPABASE_HOST),
                'resolved_ip': self.ip_address,
                'resolution_method': None
            },
            'pool_status': {
                'exists': self.connection_pool is not None,
                'min_connections': self.config.get('min_connections', DATABASE_SUPABASE_MIN_CONNECTIONS),
                'max_connections': self.config.get('max_connections', DATABASE_SUPABASE_MAX_CONNECTIONS)
            },
            'timestamp': time.time(),
            'check_id': request_id
        }
        
        # Check basic connectivity with latency measurement
        logger.debug("[ConnReq:%s] Checking basic connectivity", request_id)
        try:
            conn_start_time = time.time()
            success, message = self.test_connection()
            conn_end_time = time.time()
            conn_duration = conn_end_time - conn_start_time
            
            metrics['basic_connectivity'] = success
            metrics['latency_ms'] = round(conn_duration * 1000, 2)
            metrics['connectivity_message'] = message
            
            if success:
                logger.debug("[ConnReq:%s] Basic connectivity check passed (latency=%.2fms)",
                            request_id, metrics['latency_ms'])
            else:
                logger.warning("[ConnReq:%s] Basic connectivity check failed: %s (latency=%.2fms)",
                              request_id, message, metrics['latency_ms'])
                return False, metrics
        except Exception as e:
            logger.error("[ConnReq:%s] Error during basic connectivity check: %s",
                        request_id, str(e))
            metrics['connectivity_error'] = str(e)
            return False, metrics
            
        # Check transaction capability
        logger.debug("[ConnReq:%s] Checking transaction capability", request_id)
        try:
            # Begin a transaction
            tx_start_time = time.time()
            transaction = self.begin_transaction()
            
            # Execute a simple query within the transaction
            with transaction.cursor() as cursor:
                cursor.execute("SELECT 1 as test")
                result = cursor.fetchone()
                
            # Commit the transaction
            self.commit_transaction(transaction)
            tx_duration = time.time() - tx_start_time
            
            metrics['transaction_capability'] = True
            metrics['transaction_duration_ms'] = round(tx_duration * 1000, 2)
            logger.debug("[ConnReq:%s] Transaction capability check passed (duration=%.2fms)",
                        request_id, metrics['transaction_duration_ms'])
        except Exception as e:
            logger.warning("[ConnReq:%s] Transaction capability check failed: %s",
                          request_id, str(e))
            metrics['transaction_error'] = str(e)
            try:
                # Attempt to rollback if transaction exists
                if 'transaction' in locals():
                    self.rollback_transaction(transaction)
                    logger.debug("[ConnReq:%s] Transaction rolled back after error", request_id)
            except Exception as rollback_error:
                logger.error("[ConnReq:%s] Error rolling back transaction: %s",
                            request_id, str(rollback_error))
                
        # Check query capability with a more complex query
        logger.debug("[ConnReq:%s] Checking query capability", request_id)
        try:
            # Execute a query that checks database statistics
            query_start_time = time.time()
            result = self.execute_query(
                "SELECT count(*) as table_count FROM information_schema.tables WHERE table_schema = 'public'"
            )
            query_duration = time.time() - query_start_time
            
            metrics['query_capability'] = True
            metrics['query_duration_ms'] = round(query_duration * 1000, 2)
            metrics['table_count'] = result[0]['table_count'] if result else 0
            
            logger.debug("[ConnReq:%s] Query capability check passed (duration=%.2fms, table_count=%d)",
                        request_id, metrics['query_duration_ms'], metrics['table_count'])
        except Exception as e:
            logger.warning("[ConnReq:%s] Query capability check failed: %s",
                          request_id, str(e))
            metrics['query_error'] = str(e)
            
        # Check connection pool status if it exists
        logger.debug("[ConnReq:%s] Checking connection pool status", request_id)
        if self.connection_pool:
            try:
                metrics['pool_status']['open_connections'] = len(self.connection_pool._used)
                metrics['pool_status']['available_connections'] = len(self.connection_pool._unused)
                metrics['pool_status']['total_connections'] = (
                    len(self.connection_pool._used) + len(self.connection_pool._unused)
                )
                
                logger.debug("[ConnReq:%s] Connection pool status: open=%d, available=%d, total=%d",
                            request_id,
                            metrics['pool_status']['open_connections'],
                            metrics['pool_status']['available_connections'],
                            metrics['pool_status']['total_connections'])
            except Exception as e:
                logger.warning("[ConnReq:%s] Error checking connection pool status: %s",
                              request_id, str(e))
                metrics['pool_status']['error'] = str(e)
        else:
            logger.warning("[ConnReq:%s] Connection pool does not exist", request_id)
                
        # Check DNS resolution - verify the hostname still resolves to the same IP
        logger.debug("[ConnReq:%s] Checking DNS resolution status", request_id)
        try:
            hostname = self.config.get('host', DATABASE_SUPABASE_HOST)
            if hostname:
                current_ip = self._resolve_with_socket(hostname)
                
                if current_ip:
                    metrics['dns_resolution']['current_ip'] = current_ip
                    metrics['dns_resolution']['ip_match'] = (current_ip == self.ip_address) if self.ip_address else False
                    metrics['dns_resolution']['resolution_method'] = '_resolve_with_socket'
                else:
                    # Try alternative resolution methods
                    for method_name in ['_resolve_with_nslookup', '_resolve_with_dig', '_resolve_with_alternative_dns']:
                        method = getattr(self, method_name)
                        current_ip = method(hostname)
                        if current_ip:
                            metrics['dns_resolution']['current_ip'] = current_ip
                            metrics['dns_resolution']['ip_match'] = (current_ip == self.ip_address) if self.ip_address else False
                            metrics['dns_resolution']['resolution_method'] = method_name
                            break
                            
                # If we couldn't resolve the hostname at all, that's a problem
                if 'current_ip' not in metrics['dns_resolution']:
                    metrics['dns_resolution']['resolution_failed'] = True
                    logger.warning("[ConnReq:%s] Failed to resolve hostname %s", request_id, hostname)
        except Exception as e:
            logger.error("[ConnReq:%s] Error checking DNS resolution: %s", request_id, str(e))
            metrics['dns_resolution']['error'] = str(e)
            
        # Determine overall health
        is_healthy = (
            metrics['basic_connectivity'] and
            metrics['transaction_capability'] and
            metrics['query_capability'] and
            metrics['pool_status']['exists'] and
            ('resolution_failed' not in metrics['dns_resolution'] or not metrics['dns_resolution']['resolution_failed'])
        )
        
        # Calculate total health check duration
        total_duration = time.time() - health_check_start
        metrics['total_check_duration_ms'] = round(total_duration * 1000, 2)
        
        if is_healthy:
            logger.info("[ConnReq:%s] Health check passed (duration=%.2fms)",
                       request_id, metrics['total_check_duration_ms'])
        else:
            logger.warning("[ConnReq:%s] Health check failed (duration=%.2fms): %s",
                          request_id, metrics['total_check_duration_ms'],
                          json.dumps({k: v for k, v in metrics.items()
                                     if k not in ['timestamp', 'check_id']}))
        
        return is_healthy, metrics