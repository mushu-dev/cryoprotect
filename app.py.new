#!/usr/bin/env python3
"""
CryoProtect Analyzer API

This is the main Flask application for the CryoProtect Analyzer API.
It provides endpoints for accessing and manipulating data in the Supabase database.
"""

import os
import hashlib
from datetime import datetime, timedelta
from flask import Flask, jsonify, g, render_template, request, redirect, url_for, session
from flask_cors import CORS
from apispec import APISpec
from apispec.ext.marshmallow import MarshmallowPlugin
from flask_apispec.extension import FlaskApiSpec
from flask_mail import Mail

# Import the new configuration system
from config import (
    # Environment-aware config object
    active_config, 
    # Main validation function
    validate_config,
    # Core settings
    APP_SECRET_KEY, APP_DEBUG, APP_TESTING, 
    APP_ENVIRONMENT, APP_NAME,
    # API settings
    API_TITLE, API_VERSION, API_BASE_URL,
    API_OPENAPI_VERSION, API_OPENAPI_URL_PREFIX,
    API_SWAGGER_UI_PATH, API_SWAGGER_UI_URL,
    # Database settings
    DATABASE_CONNECTION_MODE, DATABASE_CONNECTION_TIMEOUT,
    DATABASE_CONNECTION_LIFETIME, DATABASE_IDLE_TIMEOUT,
    DATABASE_MIN_CONNECTIONS, DATABASE_MAX_CONNECTIONS,
    # Logging settings
    LOGGING_LEVEL, LOGGING_FILE, LOGGING_LOG_TO_FILE,
    # Cache settings
    CACHING_TYPE, CACHING_REDIS_URL, CACHING_DEFAULT_TIMEOUT,
    # Rate limiting settings
    RATE_LIMITING_ENABLED, RATE_LIMITING_STORAGE_URL,
    RATE_LIMITING_STRATEGY, RATE_LIMITING_BY, 
    RATE_LIMITING_HEADERS_ENABLED, RATE_LIMITING_RETRY_AFTER,
    RATE_LIMITING_ROLES,
    # Supabase settings
    DATABASE_SUPABASE_URL, DATABASE_SUPABASE_KEY,
    DATABASE_SUPABASE_SERVICE_KEY,
    # Mail settings (from config or fallback to env)
    APP_MAIL_SERVER, APP_MAIL_PORT, APP_MAIL_USE_TLS,
    APP_MAIL_USERNAME, APP_MAIL_PASSWORD, APP_MAIL_DEFAULT_SENDER
)

from api import init_app
from api.docs import init_docs
from api.utils import get_supabase_client, authenticate_user, token_required, release_supabase_connection
from logging_enhanced import setup_enhanced_logging, get_logger, log_with_context
import logging
from api.rate_limiter import configure_rate_limiter, add_rate_limit_headers
from monitoring import init_metrics, PrometheusMiddleware
from monitoring.middleware import update_entity_counts, update_connection_pool_status
from api.observability import init_observability
from backup.backup_manager import BackupManager
from api.lab_verification_resources import LabVerificationResource, VerificationStatsResource
from api import api


# Import authentication configuration
from auth_config import (
    JWT_EXPIRY, JWT_REFRESH_EXPIRY, DEFAULT_ROLE,
    AVAILABLE_ROLES, SESSION_TIMEOUT, REFRESH_TOKEN_ROTATION,
    SECURE_COOKIES, HTTP_ONLY_COOKIES, SAME_SITE_COOKIES,
    USE_JWT_AUTH, USE_SERVICE_ROLE, USER_ID
)

# Import JWT authentication utilities
from api.jwt_auth import (
    jwt_required, role_required, get_current_user,
    extract_user_from_token, get_token_from_request
)


logger = get_logger(__name__)

from security_headers import apply_security_headers
from api.csrf import init_csrf
from api.session_security import init_session_security

def create_app(config_object=None, testing=False):
    """
    Create and configure the Flask application.

    Args:
        config_object: Configuration object to use.
        testing (bool): If True, enables testing mode and overrides config for testing. Default is False.

    Returns:
        Flask: Configured Flask application
    """
    # Validate configuration first
    validate_config()
    
    app = Flask(__name__)

    # Setup enhanced logging with ELK integration
    setup_enhanced_logging(app)
    logger.info("Starting CryoProtect Analyzer API application.",
                extra={"event_type": "application_start", "app_version": API_VERSION})
    
    # Initialize Prometheus metrics
    init_metrics(app)
    
    # Add Prometheus middleware
    prometheus_middleware = PrometheusMiddleware(app)
    
    # Initialize API observability
    init_observability(app)
    
    # Initialize backup system
    backup_enabled = os.environ.get('BACKUP_ENABLED', '0') == '1'
    if backup_enabled:
        try:
            backup_config_path = os.environ.get('BACKUP_CONFIG_PATH', 'backup/config.json')
            app.backup_manager = BackupManager(config_path=backup_config_path)
            logger.info("Backup system initialized",
                       extra={"event_type": "backup_system_init", "config_path": backup_config_path})
        except Exception as e:
            logger.error(f"Failed to initialize backup system: {str(e)}",
                        extra={"event_type": "backup_system_init_error", "error": str(e)},
                        exc_info=True)

    # Load configuration
    if config_object:
        app.config.from_object(config_object)
    else:
        # Use the environment-aware configuration
        app.config.update({
            # Core settings
            'SECRET_KEY': APP_SECRET_KEY,
            'DEBUG': APP_DEBUG,
            'TESTING': APP_TESTING,
            'ENV': APP_ENVIRONMENT,
            'API_TITLE': API_TITLE,
            'API_VERSION': API_VERSION,
            
            # API settings
            'OPENAPI_VERSION': API_OPENAPI_VERSION,
            'OPENAPI_URL_PREFIX': API_OPENAPI_URL_PREFIX,
            'OPENAPI_SWAGGER_UI_PATH': API_SWAGGER_UI_PATH,
            'OPENAPI_SWAGGER_UI_URL': API_SWAGGER_UI_URL,
            
            # Database settings
            'SUPABASE_URL': DATABASE_SUPABASE_URL,
            'SUPABASE_KEY': DATABASE_SUPABASE_KEY,
            'SUPABASE_SERVICE_KEY': DATABASE_SUPABASE_SERVICE_KEY,
            'DATABASE_CONNECTION_MODE': DATABASE_CONNECTION_MODE,
            'SUPABASE_MIN_CONNECTIONS': DATABASE_MIN_CONNECTIONS,
            'SUPABASE_MAX_CONNECTIONS': DATABASE_MAX_CONNECTIONS,
            'SUPABASE_CONNECTION_TIMEOUT': DATABASE_CONNECTION_TIMEOUT,
            'SUPABASE_CONNECTION_LIFETIME': DATABASE_CONNECTION_LIFETIME,
            'SUPABASE_IDLE_TIMEOUT': DATABASE_IDLE_TIMEOUT,
            
            # Logging
            'LOG_LEVEL': LOGGING_LEVEL,
            'LOG_FILE': LOGGING_FILE,
            'LOG_TO_FILE': LOGGING_LOG_TO_FILE,
            
            # Caching
            'CACHE_TYPE': CACHING_TYPE,
            'CACHE_REDIS_URL': CACHING_REDIS_URL,
            'CACHE_DEFAULT_TIMEOUT': CACHING_DEFAULT_TIMEOUT,
            
            # Mail settings
            'MAIL_SERVER': APP_MAIL_SERVER,
            'MAIL_PORT': APP_MAIL_PORT,
            'MAIL_USE_TLS': APP_MAIL_USE_TLS,
            'MAIL_USERNAME': APP_MAIL_USERNAME,
            'MAIL_PASSWORD': APP_MAIL_PASSWORD,
            'MAIL_DEFAULT_SENDER': APP_MAIL_DEFAULT_SENDER,
            
            # API Contact info
            'API_CONTACT_NAME': 'CryoProtect API Support',
            'API_CONTACT_EMAIL': 'support@cryoprotect.com',
            'API_LICENSE_NAME': 'MIT',
        })
    
    # Override with testing config if needed
    if testing:
        app.config['TESTING'] = True
        # Add other test-specific config overrides here if needed

    # Enable CORS with additional options for documentation access
    CORS(app, resources={
        r"/swagger-ui/*": {"origins": "*"},
        r"/api/docs/*": {"origins": "*"}
    })

    # Configure connection pooling - already set from config above
    
    # Configure rate limiting
    app.config.update({
        'RATE_LIMIT_ENABLED': RATE_LIMITING_ENABLED,
        'RATE_LIMIT_STORAGE_URL': RATE_LIMITING_STORAGE_URL,
        'RATE_LIMIT_STRATEGY': RATE_LIMITING_STRATEGY,
        'RATE_LIMIT_BY': RATE_LIMITING_BY,
        'RATE_LIMIT_HEADERS_ENABLED': RATE_LIMITING_HEADERS_ENABLED,
        'RATE_LIMIT_RETRY_AFTER': RATE_LIMITING_RETRY_AFTER,
        'RATE_LIMIT_ROLES': RATE_LIMITING_ROLES
    })
    
    # Initialize API
    init_app(app)

    # Register OpenAPI documentation blueprint
    from api.openapi import register_openapi_blueprint
    register_openapi_blueprint(app)
    
    # Add Swagger UI route
    @app.route('/swagger-ui/')
    def swagger_ui():
        """Render the Swagger UI interface."""
        return render_template('swagger.html')
    
    # Initialize rate limiter
    configure_rate_limiter(app)
    
    # Initialize CSRF protection
    init_csrf(app)
    
    # Initialize session security
    init_session_security(app)
    
    # Apply security headers to all responses
    apply_security_headers(app)
    
    # Configure Flask-Mail
    mail = Mail(app)
    
    # Register error handlers with standardized response format
    from api.api_standards import create_error_response, jsonify_standard_response
    
    @app.errorhandler(400)
    def bad_request(error):
        log_with_context(
            logger, 'warning',
            f"Bad request: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "bad_request",
                "error_details": str(error)
            }
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=400,
                context="Bad request"
            )
        )
    
    @app.errorhandler(401)
    def unauthorized(error):
        log_with_context(
            logger, 'warning',
            f"Unauthorized access: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "unauthorized",
                "error_details": str(error)
            }
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=401,
                context="Unauthorized access"
            )
        )
    
    @app.errorhandler(403)
    def forbidden(error):
        log_with_context(
            logger, 'warning',
            f"Forbidden access: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "forbidden",
                "error_details": str(error)
            }
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=403,
                context="Forbidden access"
            )
        )
    
    @app.errorhandler(404)
    def not_found(error):
        log_with_context(
            logger, 'warning',
            f"Resource not found: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "not_found",
                "error_details": str(error),
                "path": request.path if request else "unknown"
            }
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=404,
                context="Resource not found"
            )
        )
    
    @app.errorhandler(409)
    def conflict(error):
        log_with_context(
            logger, 'warning',
            f"Conflict: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "conflict",
                "error_details": str(error)
            }
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=409,
                context="Resource conflict"
            )
        )
    
    @app.errorhandler(429)
    def too_many_requests(error):
        log_with_context(
            logger, 'warning',
            f"Too many requests: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "rate_limit",
                "error_details": str(error),
                "ip_address": request.remote_addr if request else "unknown"
            }
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=429,
                context="Too many requests"
            )
        )
    
    @app.errorhandler(500)
    def server_error(error):
        log_with_context(
            logger, 'error',
            f"Internal server error: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "server_error",
                "error_details": str(error)
            },
            exc_info=True
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=500,
                context="Internal server error"
            )
        )
    
    @app.errorhandler(503)
    def service_unavailable(error):
        log_with_context(
            logger, 'error',
            f"Service unavailable: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "service_unavailable",
                "error_details": str(error)
            }
        )
        return jsonify_standard_response(
            *create_error_response(
                error=str(error),
                status_code=503,
                context="Service unavailable"
            )
        )
        
    # Add a catch-all exception handler
    @app.errorhandler(Exception)
    def handle_exception(error):
        log_with_context(
            logger, 'error',
            f"Uncaught exception: {str(error)}",
            context={
                "event_type": "error",
                "error_type": "uncaught_exception",
                "error_details": str(error),
                "error_class": error.__class__.__name__
            },
            exc_info=True
        )
        return jsonify_standard_response(
            *create_error_response(
                error=error,
                context="Uncaught exception"
            )
        )
    
    # Register before request handler
    @app.before_request
    def before_request():
        # Initialize Supabase client
        try:
            get_supabase_client()
        except Exception as e:
            log_with_context(
                logger, 'error',
                f"Error initializing Supabase client: {str(e)}",
                context={
                    "event_type": "database_error",
                    "error_type": "supabase_init_error",
                    "error_details": str(e)
                },
                exc_info=True
            )
            # Don't abort here, let the request continue and fail gracefully if needed
    
    # Register teardown request handler
    @app.teardown_request
    def teardown_request(exception=None):
        # Clean up resources
        try:
            if hasattr(g, 'supabase'):
                # Release connection back to the pool if using connection pooling
                release_supabase_connection()
                
                # Update connection pool metrics
                if app.config.get('SUPABASE_CONNECTION_POOL_ENABLED', False):
                    active = app.config.get('SUPABASE_ACTIVE_CONNECTIONS', 0)
                    idle = app.config.get('SUPABASE_IDLE_CONNECTIONS', 0)
                    max_conn = app.config.get('SUPABASE_MAX_CONNECTIONS', 10)
                    update_connection_pool_status(active, idle, max_conn)
                
                # For non-pooled connections, just delete the reference
                if hasattr(g, 'supabase'):
                    del g.supabase
        except Exception as e:
            log_with_context(
                logger, 'error',
                f"Error in teardown_request: {str(e)}",
                context={
                    "event_type": "resource_cleanup_error",
                    "error_type": "teardown_error",
                    "error_details": str(e)
                },
                exc_info=True
            )
    
    # Register after request handler to add rate limit headers and log responses
    @app.after_request
    def after_request(response):
        # Add rate limit headers to response
        response = add_rate_limit_headers(response)
        
        # Log response details if not a static file or health check
        if not request.path.startswith('/static/') and request.path != '/health':
            status_code = response.status_code
            log_level = 'warning' if status_code >= 400 else 'info'
            
            # Calculate request duration if start_time was set
            duration = None
            if hasattr(g, 'start_time'):
                # Use utcnow() to match the utcnow() used in logging_enhanced.py
                duration = (datetime.utcnow() - g.start_time).total_seconds()
            
            # Get user ID if available
            user_id = getattr(g, 'user_id', 'anonymous')
            
            # Log response with context
            log_with_context(
                logger, log_level,
                f"Response: {request.method} {request.path} {status_code}",
                context={
                    "event_type": "response",
                    "request": {
                        "method": request.method,
                        "path": request.path,
                        "remote_addr": request.remote_addr
                    },
                    "response": {
                        "status_code": status_code,
                        "content_length": response.content_length,
                        "content_type": response.content_type,
                        "duration": duration
                    },
                    "user_id": user_id,
                    "correlation_id": getattr(g, 'correlation_id', 'N/A')
                }
            )
            
            # Update business metrics periodically (every 10 requests)
            if hasattr(app, '_request_count'):
                app._request_count += 1
            else:
                app._request_count = 1
                
            if app._request_count % 10 == 0 and hasattr(g, 'supabase'):
                try:
                    update_entity_counts(g.supabase)
                except Exception as e:
                    logger.error(f"Error updating entity counts: {str(e)}")
        
        return response
    
    # Add health check endpoint
    # Main health check endpoint for overall system health
    @app.route('/health')
    def health_check():
        try:
            # Get deployment color from environment
            deployment_color = os.environ.get('DEPLOYMENT_COLOR', 'production')
            
            # Check database connection
            supabase = get_supabase_client()
            response = supabase.from_("property_types").select("*").limit(1).execute()
            db_status = "connected" if hasattr(response, 'data') else "unknown"

            # Check Redis connection if configured
            redis_status = "not_configured"
            redis_url = (
                app.config.get("CACHE_REDIS_URL")
                or app.config.get("RATE_LIMIT_STORAGE_URL")
                or os.environ.get("REDIS_URL")
            )
            if redis_url and "redis" in redis_url:
                try:
                    import redis as redis_lib
                    from urllib.parse import urlparse

                    # Parse Redis URL
                    parsed = urlparse(redis_url)
                    redis_host = parsed.hostname
                    redis_port = parsed.port or 6379
                    redis_db = int(parsed.path.lstrip("/")) if parsed.path else 0
                    redis_password = parsed.password

                    r = redis_lib.StrictRedis(
                        host=redis_host,
                        port=redis_port,
                        db=redis_db,
                        password=redis_password,
                        socket_connect_timeout=2,
                        socket_timeout=2,
                    )
                    if r.ping():
                        redis_status = "connected"
                    else:
                        redis_status = "unreachable"
                except Exception as re:
                    redis_status = f"error: {str(re)}"
            
            # Check disk space
            disk_status = "unknown"
            try:
                import shutil
                total, used, free = shutil.disk_usage("/")
                disk_free_percent = (free / total) * 100
                disk_status = "ok" if disk_free_percent > 10 else "low"
            except Exception as de:
                disk_status = f"error: {str(de)}"
            
            # Check memory usage
            memory_status = "unknown"
            try:
                import psutil
                memory = psutil.virtual_memory()
                memory_status = "ok" if memory.percent < 90 else "high"
            except Exception as me:
                # psutil might not be available in all environments
                memory_status = "not_available"
            
            # Check for required environment variables
            env_vars = ["FLASK_APP", "FLASK_ENV", "SECRET_KEY"]
            missing_vars = [var for var in env_vars if not os.environ.get(var)]
            env_status = "ok" if not missing_vars else f"missing: {', '.join(missing_vars)}"
            
            # Determine overall status
            overall_status = "ok"
            if db_status != "connected" or (redis_url and redis_status != "connected") or disk_status == "low" or memory_status == "high" or env_status != "ok":
                overall_status = "degraded"

            # Log health check
            log_with_context(
                logger, 'info',
                "Health check completed",
                context={
                    "event_type": "health_check",
                    "status": overall_status,
                    "database_status": db_status,
                    "redis_status": redis_status,
                    "disk_status": disk_status,
                    "memory_status": memory_status,
                    "env_status": env_status,
                    "api_version": app.config['API_VERSION'],
                    "deployment_color": deployment_color
                }
            )

            # Return health status
            return jsonify({
                'status': overall_status,
                'version': app.config['API_VERSION'],
                'deployment': deployment_color,
                'timestamp': datetime.now().isoformat(),
                'services': {
                    'database': db_status,
                    'redis': redis_status,
                    'disk': disk_status,
                    'memory': memory_status,
                    'environment': env_status
                }
            }), 200 if overall_status == "ok" else 207  # 207 Multi-Status for degraded
        except Exception as e:
            log_with_context(
                logger, 'error',
                f"Health check failed: {str(e)}",
                context={
                    "event_type": "health_check",
                    "status": "failed",
                    "error_details": str(e),
                    "api_version": app.config['API_VERSION']
                },
                exc_info=True
            )
            return jsonify({
                'status': 'error',
                'version': app.config['API_VERSION'],
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }), 500
    
    # Liveness probe - lightweight check to verify the application is running
    @app.route('/health/liveness')
    def liveness_check():
        try:
            # Simple check that the app is running
            return jsonify({
                'status': 'alive',
                'timestamp': datetime.now().isoformat()
            }), 200
        except Exception as e:
            return jsonify({
                'status': 'error',
                'error': str(e)
            }), 500
    
    # Readiness probe - check if the application is ready to serve traffic
    @app.route('/health/readiness')
    def readiness_check():
        try:
            # Check database connection
            supabase = get_supabase_client()
            response = supabase.from_("property_types").select("*").limit(1).execute()
            db_ready = hasattr(response, 'data')
            
            # Check if required services are available
            services_ready = db_ready
            
            # Return readiness status
            if services_ready:
                return jsonify({
                    'status': 'ready',
                    'timestamp': datetime.now().isoformat()
                }), 200
            else:
                return jsonify({
                    'status': 'not_ready',
                    'reason': 'Required services not available',
                    'timestamp': datetime.now().isoformat()
                }), 503
        except Exception as e:
            return jsonify({
                'status': 'not_ready',
                'reason': str(e),
                'timestamp': datetime.now().isoformat()
            }), 503
    
    # Startup probe - check if the application has completed startup
    @app.route('/health/startup')
    def startup_check():
        try:
            # Check if all required components are initialized
            all_initialized = True
            
            # Check database connection
            try:
                supabase = get_supabase_client()
                response = supabase.from_("property_types").select("*").limit(1).execute()
                db_initialized = hasattr(response, 'data')
                all_initialized = all_initialized and db_initialized
            except:
                all_initialized = False
            
            # Return startup status
            if all_initialized:
                return jsonify({
                    'status': 'started',
                    'timestamp': datetime.now().isoformat()
                }), 200
            else:
                return jsonify({
                    'status': 'starting',
                    'timestamp': datetime.now().isoformat()
                }), 503
        except Exception as e:
            return jsonify({
                'status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }), 500

    # Rest of the file is unchanged...
    # Include the remaining routes and handler functions here
    
    # Register routes for authentication, backup health check, etc.
    # (Rest of the implementation from original app.py)
    
    # Register session management routes
    from api.session_routes import register_session_routes
    register_session_routes(app)
    
    # Start session cleanup thread
    from api.session_utils import start_session_cleanup_thread
    start_session_cleanup_thread()
    
    apply_security_headers(app)
    return app

# Create the app instance
app = create_app()

# Middleware to check authentication for protected routes
def auth_middleware():
    @app.before_request
    def check_auth():
        # List of routes that require authentication
        protected_routes = [
            '/profile',
            '/molecules',
            '/mixtures',
            '/predictions',
            '/experiments',
            '/comparisons',
            '/protocol-designer',
            '/predictive-models',
            '/teams'
        ]
        
        # API routes that should be excluded from web authentication
        api_routes = ['/api/', '/auth/']

        # Allow unauthenticated GET access to molecules and mixtures pages
        public_get_routes = [
            '/molecules',
            '/molecules/rdkit',
            '/molecules/integrated',
            '/mixtures'
        ]
        if request.method == 'GET' and any(request.path == route for route in public_get_routes):
            return  # Allow public access to these GET routes

        # Check if the current route is protected and not an API route
        if any(request.path.startswith(route) for route in protected_routes) and \
           not any(request.path.startswith(route) for route in api_routes):
            # Check if user is authenticated
            user = get_current_user()
            if not user:
                # If the request accepts JSON, return a JSON response
                if request.headers.get('Accept', '').find('application/json') != -1:
                    return jsonify({'message': 'Authentication required'}), 401
                
                # Otherwise redirect to login page
                return redirect(url_for('login_page',
                                       next=request.path,
                                       error="Please login to access this page"))
    
    # Add context processor to make current_user available in templates
    @app.context_processor
    def inject_user():
        user = get_current_user()
        # Create a user object with is_authenticated property for templates
        class CurrentUser:
            def __init__(self, user_data):
                self.is_authenticated = user_data is not None
                self.data = user_data
                
            def __getattr__(self, name):
                if self.data and name in self.data:
                    return self.data[name]
                return None
                
        return {'current_user': CurrentUser(user)}

# Register the authentication middleware
auth_middleware()

# Add routes for the web interface
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/molecules')
def molecules():
    return render_template('molecules.html')

@app.route('/molecules/rdkit')
def molecules_rdkit():
    return render_template('molecules_rdkit.html')

@app.route('/molecules/integrated')
def molecules_integrated():
    return render_template('molecules_integrated.html')

@app.route('/mixtures')
def mixtures():
    return render_template('mixtures.html')

@app.route('/predictions')
def predictions():
    return render_template('predictions.html')

@app.route('/predictive-models')
def predictive_models():
    return render_template('predictive_models.html')

@app.route('/experiments')
def experiments():
    return render_template('experiments.html')

@app.route('/comparisons')
def comparisons():
    return render_template('comparisons.html')

@app.route('/login')
def login_page():
    # Pass Supabase configuration to the template
    return render_template('login.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'])

@app.route('/register')
def register_page():
    # Pass Supabase configuration to the template
    return render_template('register.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'])

@app.route('/profile')
def profile_page():
    # Pass Supabase configuration to the template
    return render_template('profile.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'])

@app.route('/reset-password')
def reset_password_page():
    # Pass Supabase configuration to the template
    return render_template('reset_password.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'])

@app.route('/protocol-designer')
def protocol_designer_page():
    # Pass Supabase configuration to the template
    return render_template('protocol_designer.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'])

@app.route('/dashboard')
def dashboard_page():
   # Pass Supabase configuration to the template
   return render_template('dashboard.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'])

@app.route('/property-explorer')
@token_required
def property_explorer():
   # Pass Supabase configuration to the template
   current_user = get_current_user()
   return render_template('property_explorer.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'],
                          user=current_user)

@app.route('/api/v1/test/rate-limit')
def test_rate_limit():
   """
   Test endpoint to demonstrate rate limiting.
   This endpoint is limited to 5 requests per minute.
   """
   from api.rate_limiter import endpoint_rate_limit
   
   # Apply rate limit to this endpoint
   endpoint_rate_limit("5 per minute")(test_rate_limit)
   
   return jsonify({
       'status': 'success',
       'message': 'Rate limit test endpoint',
       'timestamp': datetime.now().isoformat()
   })

@app.route('/teams')
def teams_page():
   # Pass Supabase configuration to the template
   return render_template('teams.html',
                          supabase_url=app.config['SUPABASE_URL'],
                          supabase_key=app.config['SUPABASE_KEY'])

# Authentication endpoints and remaining routes would go here
# They were omitted for brevity, but would be included in a complete implementation

if __name__ == '__main__':
    # Initialize the app without trying to authenticate
    # Authentication will happen during requests
    app.logger.info("Starting CryoProtect Analyzer API")
    
    # Log service role status
    if USE_SERVICE_ROLE:
        app.logger.info(f"Service role authentication is enabled with user ID: {USER_ID}")
    else:
        app.logger.info("Service role authentication is disabled")
    
    # Run the application
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)