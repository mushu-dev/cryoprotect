#!/usr/bin/env node
/**
 * Generate TypeScript types for Convex schema
 * 
 * This script generates TypeScript type definitions from the Convex schema
 * for use in the frontend application. It ensures type safety when working
 * with data from Convex.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const CONVEX_SCHEMA_DIR = path.join(__dirname, 'convex/schema');
const FRONTEND_TYPES_DIR = path.join(__dirname, 'frontend/src/types/convex');
const CONVEX_GENERATED_DIR = path.join(__dirname, 'convex/_generated');

// Ensure the types directory exists
if (!fs.existsSync(FRONTEND_TYPES_DIR)) {
  fs.mkdirSync(FRONTEND_TYPES_DIR, { recursive: true });
}

/**
 * Generate Convex types using the Convex CLI
 */
function generateConvexTypes() {
  console.log('Generating Convex types...');
  try {
    // Run the Convex CLI to generate types
    execSync('npx convex codegen', { stdio: 'inherit' });
    console.log('Successfully generated Convex types.');
    return true;
  } catch (error) {
    console.error('Error generating Convex types:', error.message);
    return false;
  }
}

/**
 * Copy and transform generated types to frontend
 */
function copyTypesToFrontend() {
  console.log('Copying types to frontend...');

  try {
    // Read the generated data model
    const dataModelPath = path.join(CONVEX_GENERATED_DIR, 'dataModel.d.ts');
    if (!fs.existsSync(dataModelPath)) {
      console.error('Generated dataModel.d.ts not found. Make sure to run `npx convex codegen` first.');
      return false;
    }

    const dataModelContent = fs.readFileSync(dataModelPath, 'utf8');

    // Extract document type definitions
    const documentTypesContent = extractDocumentTypes(dataModelContent);

    // Create a new TypeScript file for frontend
    const frontendTypesContent = `/**
 * Generated Convex Types
 * 
 * This file contains TypeScript types generated from the Convex schema.
 * DO NOT EDIT THIS FILE DIRECTLY. Instead, modify the schema files in
 * the convex/schema directory and regenerate this file.
 * 
 * Generated on: ${new Date().toISOString()}
 */

${documentTypesContent}

/**
 * Helper types for working with Convex documents
 */
export type WithId<T> = T & { id: string };
export type WithOptionalId<T> = T & { id?: string };
export type OptionalTimestamps<T> = Omit<T, 'createdAt' | 'updatedAt'> & { 
  createdAt?: number; 
  updatedAt?: number; 
};
`;

    // Write the file
    fs.writeFileSync(path.join(FRONTEND_TYPES_DIR, 'types.ts'), frontendTypesContent);
    
    // Also copy the generated API types
    const apiPath = path.join(CONVEX_GENERATED_DIR, 'api.d.ts');
    if (fs.existsSync(apiPath)) {
      const apiContent = fs.readFileSync(apiPath, 'utf8');
      fs.writeFileSync(path.join(FRONTEND_TYPES_DIR, 'api.ts'), apiContent);
    }

    console.log('Successfully copied types to frontend.');
    return true;
  } catch (error) {
    console.error('Error copying types to frontend:', error.message);
    return false;
  }
}

/**
 * Extract document type definitions from generated dataModel.d.ts
 */
function extractDocumentTypes(content) {
  // Extract the DocumentByTableName interface which contains all document types
  const docTypeMatch = content.match(/export interface DocumentByTableName\s*{[^}]*}/s);
  
  if (!docTypeMatch) {
    console.warn('Could not find DocumentByTableName interface in generated types.');
    return '';
  }
  
  const docTypeInterface = docTypeMatch[0];
  
  // Extract individual document types
  const documentTypes = [];
  const tablePattern = /(\w+)\s*:\s*{([^}]*)}/g;
  let match;
  
  while ((match = tablePattern.exec(docTypeInterface)) !== null) {
    const tableName = match[1];
    const tableFields = match[2].trim();
    
    // Create a standalone interface for each document type
    documentTypes.push(`export interface ${capitalize(tableName)}Document {
  ${tableFields}
}`);
  }
  
  return documentTypes.join('\n\n');
}

/**
 * Capitalize the first letter of a string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Create an index file with exports for all generated types
 */
function createIndexFile() {
  const indexContent = `/**
 * Convex Types Index
 * 
 * This file exports all Convex types for use in the frontend.
 */

export * from './types';
export * from './api';
`;
  
  fs.writeFileSync(path.join(FRONTEND_TYPES_DIR, 'index.ts'), indexContent);
  console.log('Created index file for Convex types.');
}

/**
 * Main function
 */
function main() {
  // Generate Convex types
  const typesGenerated = generateConvexTypes();
  if (!typesGenerated) {
    console.error('Failed to generate Convex types. Aborting.');
    process.exit(1);
  }
  
  // Copy types to frontend
  const typesCopied = copyTypesToFrontend();
  if (!typesCopied) {
    console.error('Failed to copy types to frontend. Aborting.');
    process.exit(1);
  }
  
  // Create index file
  createIndexFile();
  
  console.log('Successfully generated and copied Convex types to frontend.');
}

// Run the script
main();